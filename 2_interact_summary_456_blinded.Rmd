---
title: 'InterACT project: outcomes 4, 5 and 6. Version with blinded hospitals.'
author: "Adrian Barnett"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  word_document:
    toc: true
    toc_depth: 2
    reference_docx: rmarkdown-styles-reference.docx
bibliography: references.bib
---

```{r setup, include=FALSE}
# using formatting in Word document (see above)
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE, error=FALSE, comment='', dpi=400, dev = "ragg_png")
options(width=1000) # Wide pages
options(scipen=999) # avoid scientific presentation
source('99_functions.R')
source('99_functions_not_shared.R')
library(diagram) # for flow diagram
library(boot) # for bootstrap confidence intervals - only if using survival difference
library(rms) # for survival estimates
library(cmprsk) # for cumulative incidence
library(broom) # for regression models
library(dplyr)
library(tidyr)
library(janitor) # for tables with column totals
library(stringr)
library(flextable)
library(mitools) # for MIcombine

# graphics things:
library(ragg) # because of ribbon issue
library(ggplot2)
library(ggupset)  # to plot combination of reviews
library(survminer) # for survival plots
library(gridExtra)
g.theme = theme_bw() + theme(panel.grid.minor = element_blank())
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#999999", "#CC79A7") # colour-blind palette

# start with the unscrambled data
source('1_not_scramble_data.R')

# prediction time used to truncate survival plots and for prediction of risk difference:
pred_time = 21 # 3 weeks
n_boot = 3000 # number of bootstrap samples for risk difference, increase to 3000 for final run

# scramble intervention (turn off -- FALSE -- when ready)
scramble = FALSE # 
if(scramble == TRUE){
  source('1_scramble_data.R')
}

# blind hospital
baseline = mutate(baseline, 
                  hospital = deidentify_hospital(hospital),
                  hosp_ordered = factor(hospital, levels=c('X','Y','Z'), ordered =TRUE))
survival_data  = mutate(survival_data, 
                        hospital = deidentify_hospital(hospital),
                        hosp_ordered = factor(hospital, levels=c('X','Y','Z'), ordered =TRUE))
for (k in 1:10){
  care_directive_imputed[[k]] = mutate(care_directive_imputed[[k]], hospital = deidentify_hospital(hospital))
  survival_data_imputed[[k]] = mutate(survival_data_imputed[[k]], hospital = deidentify_hospital(hospital))
}
clinicianled_review = mutate(clinicianled_review, hospital = deidentify_hospital(hospital))
palliative_care_referral = mutate(palliative_care_referral, hospital = deidentify_hospital(hospital))
  
# create small subset of variables to add to outcome data
data_to_add = select(baseline, participant_id, pt_sex, age, cristal_score, spict_score, team)
```

This report covers outcomes 4, 5 and 6. Other outcomes will be examined later as more data becomes available. 

* Outcome 4: Time to first clinician-led care review discussion

* Outcome 5: Time to first review of care directive documents  

* Outcome 6: Time to first palliative care referrals 

We only examine patients classified as "at risk" due to a positive SPICT or CRiSTAL screening. In two clinical teams at one hospital the threshold for SPICT increased from 2 to 3 as it was deemed too be too sensitive for the patient mix in these team. 

### Relevant sections from the protocol

* "Outcomes 2 to 7 will use competing-risk, proportional hazards survival models."

* "analyses [...] will be adjusted for potential confounders of patient age and sex, unless specified otherwise. Additionally, the fitted models will be assessed for adequacy of model fit to data and tested for violations of model assumptions."

* "There is a potential risk that the censoring will be statistically informative as it is more likely to affect patients with long hospital stays. We will compare patient characteristics, notably their length of stay and other study outcomes listed below, of those who were censored with those who were not censored. If large differences are detected, the survival models will be adapted to use inverse probability censoring weighting estimators to explicitly account for the informative censoring."

* "We plan to perform a sensitivity analysis on the time scale used in the survival analyses for Outcomes 2 to 7. The proposed sensitivity analysis will reanalyse the data, using calendar time in conjunction with, and in place of, time since admission to enrolled medical team."

* "A separate sensitivity analysis is proposed to include a weekend and after-hours time-varying indicator covariate in the survival analyses."

* "Patient record screening data collection will continue through the intervention establishment phase but will not be part of the data analysis."

* "(Outcome 5) We will examine the impact of time to documentation of continuing active treatment or family conflict, which could be a strong competing risk for documentation of care review activities. We will examine the interplay between these events using data from the usual care exposure period only, and consider whether and how to add continuing active treatment to the survival model."

*	"The third planned sensitivity analysis evaluates the interaction between SPICT and CriSTAL scores with the outcomes and intervention effect. It is plausible that patients with higher scores might have poorer outcomes, and a stronger intervention effect. This sensitivity analysis involves the addition of the SPICT and CriSTAL scores, and interaction terms between the scores and intervention indicator covariate, as covariates in the statistical models."

* "As an exploratory data analysis, we will compare the time between patient admission to the recruited clinical team to first high-risk CriSTAL or SPICT-positive identification in the usual care period with the corresponding duration in the intervention period"

# Scrambled data

This document contains the statistical analyses for the InterACT study. The initial document was produced using a scrambled data by randomly re-ordering the data so that patients ages, gender, intervention phase and outcomes are mixed up. This means any effect of the intervention would be erased. This allowed us to finalise the statistical analyses plan and ensure that all investigators agreed with the analyses before the real data were used.

This report is not scrambled and shows the outcome analyses for the InterACT study using the data available on `r format(data_date, '%d-%b%-%Y')`. The R code is available on [GitHub](https://github.com/agbarnett/InterACT).

#### Establishment phase

The establishment phase was the four-week change-over time between the usual care and intervention times.
We included patients from the establishment phase in the descriptive tables, but excluded them from the survival models. 

#### Time-to-event analyses

The time-to-event analyses used the time to the first "Yes" outcome (e.g., time to first clinical-led care review). For patients with only "No" outcomes, the time was censored at the date/time of their last "No" outcome. 

We used Cox models that were stratified on team (within hospital), which meant that each team had its own baseline hazard, which allowed for differences in the ways teams typically manage patients. We could then estimate the change in hazards (times-to-event) due to the intervention. The variables in the model were the potential confounders of age, sex, CRiSTAL and SPICT score, and the intervention phase which used a reference category of "usual care". Age was scaled to a 5-year increase to make the estimates more clinically meaningful. Teams were adjusted for using the baseline hazard.

We checked the proportional hazards assumption for the Cox models using a graphical check rather than a formal statistical test as the statistical test may have limited utility [@Stensrud2020]. The graphical test helps locate the time of any non-proportional effects. 

#### Missing outcome times

Some outcomes are missing the exact time the outcome took place. They should have the date, but not the time. This is because this was often not recorded in the notes. These results are not included in the plots that examine the hour of day. In the time-to-event analyses, these results were assumed to occur 1 minute before midnight on the same day. 


###### page break

# Basic information

## Stepped-wedge date changes

```{r}
load('data/date_changes.RData') # from ?.R
date_changes = mutate(date_changes, hospital = deidentify_hospital(hospital)) # blind
date_changes = mutate(date_changes, 
      days_uc = 1 + as.numeric(date_establishment) - as.numeric(date_usual_care),
      days_int = 1 + as.numeric(date_post) - as.numeric(date_intervention  )) %>%
    select(-date_end) %>%
  mutate_if(lubridate::is.Date, my.date.format) %>%
  arrange(days_uc) %>% # arrange results by date of change
  rename('Usual care' = 'date_usual_care',
         'Establishment' = 'date_establishment',
         'Intervention' = 'date_intervention',
         'End of intervention' = 'date_post',
         'Days in usual care' = 'days_uc',
         'Days in intervention' = 'days_int')
ftab = flextable(date_changes) %>%
  theme_box() %>%
  fontsize(size=9, part='all') %>%
  width( width = c(0.8, 1.0, 1.1, 1.0, 1.0, 1, 1))
ftab
# I have verified that times in weeks are either 16, 25 or 34
```
  
The table above shows the key times in each of the three hospitals and the number of days in the usual care and intervention phases.

## Patient age

The plot is split by patients who were either CriSTAL or SPICT positive.

```{r, out.width='100%', fig.width=7}
to_plot = filter(baseline, redcap_version == 3, !is.na(at_risk))
p <- ggplot(to_plot, aes(x=hosp_ordered, y=age, fill=factor(hospital))) + 
  scale_fill_manual('Hospital', values=cbPalette) +
  geom_violin(alpha=0.5) +
  geom_boxplot(width=0.1) +
  xlab('Hospital') +
  ylab('Age') +
  g.theme+
  facet_wrap(~at_risk)
p
```

## Patient gender 

The table is split by patients who were either CriSTAL or SPICT positive.

```{r}
table = group_by(to_plot, hospital, at_risk, pt_sex) %>%
  tally() %>%
  group_by(hospital, pt_sex) %>%
  mutate(p = round(prop.table(n)*100),
         cell = paste(n, ' (', p, ')', sep='')) %>%
  select(-n, -p) %>%
  pivot_wider(values_from=cell, names_from='at_risk') %>%
  rename('Gender' = 'pt_sex') %>%
  arrange(desc(hospital, Gender)) # in order of intervention
ftab = flextable(table) %>%
  theme_box() %>%
  autofit()
ftab
```

## Numbers at risk in each phase

```{r}
table = filter(baseline, 
               redcap_version == 3,
               at_risk=="At risk") %>%
  tabyl(hospital, int_time) %>%
  arrange(desc(hospital, Gender)) %>% # in order of intervention
  adorn_totals("row") 
ftab = flextable(table) %>%
  theme_box() %>%
  autofit()
ftab
```

These numbers reflect the timing of the intervention in each hospital. 

## At-risk numbers with outcomes 4, 5 or 6 not recorded

```{r}
small1 = filter(care_directive_imputed[[1]], redcap_version == 3) %>%
  select(participant_id, hospital) %>%
  unique() %>%
  mutate(care_directive = TRUE) # outcome 5
small2 = filter(clinicianled_review, redcap_version == 3) %>%
  select(participant_id, hospital)  %>%
  unique() %>%
  mutate(clinical_review = TRUE) # outcome 4
small3 = filter(palliative_care_referral, redcap_version == 3) %>%
  select(participant_id, hospital)  %>%
  unique() %>% # just one per patient
  mutate(palliative_care = TRUE) # outcome 6
for_table = filter(baseline, 
                   redcap_version == 3,
                   at_risk == "At risk") %>%
  select(participant_id, hospital, int_time) %>%
  full_join(small1, by=c('participant_id','hospital')) %>%
  full_join(small2, by=c('participant_id','hospital')) %>%
  full_join(small3, by=c('participant_id','hospital')) %>%
  mutate(
    int_time = as.character(int_time),
    care_directive = ifelse(is.na(care_directive)==TRUE, FALSE, care_directive),
         clinical_review = ifelse(is.na(clinical_review)==TRUE, FALSE, clinical_review),
         palliative_care = ifelse(is.na(palliative_care)==TRUE, FALSE, palliative_care)) %>%
  filter(!is.na(int_time)) %>% # remove small number that were not at risk but some data collection was started
  pivot_longer(cols=c(care_directive, clinical_review, palliative_care)) %>%
  mutate(number = case_when(
    name == 'clinical_review' ~ 4,
    name == 'care_directive' ~ 5,
    name == 'palliative_care' ~ 6
  ))
         
# tabulate
table = group_by(for_table, int_time, hospital, number, name) %>%
  summarise(n=sum(value), N=n()) %>%
  ungroup() %>%
  mutate(percent = round((N-n)*100/N), # percent not complete
         cell = paste(N-n, '/', N, ' (', percent, ')', sep='')) %>%
  select(-n, -N, -percent) %>%
  pivot_wider(names_from = int_time, values_from=cell) %>%
  select('hospital','number','name','Usual care','Establishment','Intervention') %>% # column ordering
  arrange(desc(hospital), number) %>% # in order of intervention
  mutate(name = str_replace_all(name, '_', ' ')) %>%
  mutate_all(zeros) %>% # replace blanks with zeros
  rename('Outcome number' = 'number',
         'Outcome' = 'name')
ftab = flextable(table) %>%
  theme_box() %>%
  merge_v(j=1) %>%
  width( width = c(0.9, 0.9, 0.9, 1.1, 1.2, 1.1))
ftab
```

The table shows the numbers and percentages (in parentheses) where the outcomes 4, 5 and 6 are not completed. So lower percentages indicate a good coverage of the outcomes. The results are split by hospital and only apply to at-risk patients (either CRiSTAL or SPICT positive). 

The screening not complete is for patients who were not at risk.

<!--- The screening not complete column comes from the "Screening completion" form in REDCap.--->

# Clinician-led review discussion

The results in this section only use the first clinician-led review discussion per patient. For patients without a care review discussion, we used their final completed follow-up form.


### Has a clinician-led care review discussion occurred?

```{r}
# results split by hospital - changed after unscrambling
stats = filter(survival_data, outcome== 'care_review') %>%
  mutate(event = ifelse(event %in% c('No','Intervention','Post-intervention'), "Censored", event)) %>% # Added
  group_by(int_time, hospital, event) %>%
  tally()
stats2 = group_by(stats, hospital, int_time) %>%
  mutate(p = round(100*prop.table(n)),
         cell = paste(n, ' (', p, ')', sep='')) %>%
  select(-n, -p) %>%
  pivot_wider(names_from = event, values_from = cell)
# add totals 
totals = group_by(stats, hospital, int_time) %>%
  summarise(Total = sum(n),
            Total = paste(Total, ' (100)', sep=''))
#
to_table = left_join(stats2, totals, by=c('hospital','int_time')) %>%
  select(hospital, int_time, Censored, Discharge, Prior, Yes, Total) %>% # order rows
  arrange(desc(hospital), int_time) %>% # by order of intervention
  rename('Intervention time' = 'int_time') %>%
  mutate_all(zeros)
ftab = flextable(to_table) %>%
  theme_box() %>%
  merge_v(j=1) %>%
  autofit()
ftab
```

The table shows the number of patients and row percentages in parentheses.

"Prior" means a clinician-led care review discussion had taken place prior to this admission. The other outcomes of "No", "Yes" and "Censored" are during the index admission. 

### Days and times when clinical-led discussions took place

```{r, out.width='100%'}
to_plot = circular_plots(indata = clinicianled_review, 
                         var = 'care_review',
                         datetime = 'time_care_review',
                         blind = TRUE)
print(to_plot$week)
```

The results are standardised to the numbers per week because the hospitals had different times in the usual care and intervention phases.

There were `r to_plot$missing_hour` patients (`r to_plot$missing_hour_percent` %) that were missing the exact time the review took place and are not included in these plots.

```{r, out.width='100%'}
print(to_plot$hour)
```


### Type of clinician-led discussion activity

```{r, results='asis'}
# only one box can be ticked
table = filter(clinicianled_review, !is.na(care_review_type)) %>%
  tabyl(int_time, care_review_type) %>%
  adorn_totals("col") %>% # add totals
  tidyr::gather(care_review_type , n, 2:ncol(.), convert = TRUE) %>%
  group_by(int_time) %>%
  mutate(p = round(100*prop.table(n)),
         p = p*2, # because total is in calculations
         cell = paste(n, ' (', p, ')', sep='')) %>%
  select(-n, -p) %>%
  pivot_wider(names_from = int_time, values_from=cell) %>%
  rename('Care review type' = 'care_review_type')
ftab = flextable(table) %>%
  theme_box() %>%
  autofit()
ftab
```

The table shows the number of patients and percentage in parentheses.

### Time-to-event analysis of time from ward admission to first clinical-led discussion

Here we use time-to-event analysis to examine the time to the first clinical-led discussion The plot below shows the cumulative probability for the first clinical-led discussion by intervention phase.

```{r, include=FALSE}
## prepare data for cumulative and instantaneous survival models
for_model_care_review = filter(survival_data,
                  outcome == 'care_review',
                  int_time != 'Establishment') %>% # excluded from analysis
  mutate(  event = as.character(event), # needed for ifelse below
           event = ifelse(event== 'No', 'Censored', event)) # change "No" to "censored" for this analysis. Competing risks are death/discharge

# add variables from baseline data that are not in outcome data (age, sex)
for_model_care_review = left_join(for_model_care_review, data_to_add, by='participant_id')

## numbers excluded
# a) establishment
n_excluded_establishment = nrow(filter(survival_data, 
                               outcome == 'care_review',
                               int_time == 'Establishment'))
```

##### Cumulative probability plot (clinical-led discussion)

```{r, fig.width=7}
# cumulative probability plot
# plot in each hospital - change after scrambling
plot_data = NULL
for (hosp in c('X','Y','Z')){
  this_data = filter(for_model_care_review, hospital ==hosp) %>%
    mutate(
      int_timec = as.character(int_time),
      int_timec = ifelse(int_timec=='Usual care', 'UsualCare', int_timec), # ggcompetingrisks cannot handle spaces
      event = ifelse(event=='Prior', 'Yes', event), # prior count as events at early time
      eventSimple = case_when(
           event == 'Intervention' ~ 'Censored',
           event == 'Post-intervention' ~ 'Censored',
           event == 'No' ~ 'Censored',
           TRUE ~ as.character(event)
      )) 
  cum_inc = with(this_data, cuminc(ftime=time, fstatus=eventSimple, group=int_timec, cencode='Censored'))
  g = ggcompetingrisks(cum_inc,
                       xlab = 'Days',
                       ylab = 'Cumulative probability',
                       multiple_panels = FALSE,
                       title = '',
                       cumcensor = TRUE, # does not work
                       legend.title='',
                       risk.table = TRUE, # does not work
                       conf_int = TRUE) # does not work
  # combine data
  this_plot = mutate(g$data, hospital=hosp)
  plot_data = bind_rows(plot_data, this_plot)
}
# add CI
to_plot_care_review = mutate(plot_data,
                 hosp_ordered = factor(hospital, levels=c('X','Y','Z')), # to show in intervention order
                 z = qnorm(0.975),
                 lower  = est - (z*sqrt(var)),
                 upper  = est + (z*sqrt(var)),
                 group = ifelse(group=='Usual', 'Usual care', group))
# redo plot for greater control
alt_plot = ggplot(to_plot_care_review, aes(x=time, y=est, ymin=lower, ymax=upper, linetype=event, col=group)) +
#  geom_ribbon(alpha=0.2) + # too busy
  geom_line(size = 1.05) +  # make lines thicker
  scale_y_continuous(limits=c(0,1)) + # 
  coord_cartesian(xlim=c(0,pred_time))+ # limit based on censoring
  theme_bw() +
  scale_color_manual(NULL, values=cbPalette, labels=c('Intervention', 'Usual care')) +
  scale_linetype_manual(NULL, values=c(2,1), labels=c('Discharge/Death','Outcome')) +
  xlab('Days from ward admission') +
  ylab('Cumulative probability') +
  theme(legend.position = 'right',
        panel.grid.minor = element_blank()) +
  facet_wrap(~hosp_ordered)
alt_plot
# for text, number of events post cut-off
n_after = sum(for_model_care_review$time > pred_time)
percent_after = round(100*n_after / nrow(for_model_care_review))
post_cutoff = paste(n_after, ' (', percent_after, '%)', sep='')
```

We limited the plot to the first `r pred_time` days because there were only `r post_cutoff` events after this time.

The solid lines show the time to the event and the dotted line show the time to the competing risk of death or discharge (combined).

##### Time-to-event model of time to first clinical-led discussion

```{r}
# add prior events as events at early time
for_model_care_review = mutate(for_model_care_review,
                               event_plus = event,
  event_plus = ifelse(event=='Prior', 'Yes', event_plus))
# Cox model stratified on team within hospital
cox_model_care_review = coxph(Surv(time = time, event = event_plus == 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = for_model_care_review)
# number missing:
n_missing = nrow(for_model_care_review) - cox_model_care_review$n
#
ests = tidy(cox_model_care_review, conf.int = TRUE) %>%
  filter(!is.na(estimate)) %>%
  mutate(
    Variable = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    CI = paste(conf.low, ' to ' , conf.high, sep='')) %>%
  select(Variable, HR, CI)
ft = flextable(ests) %>%
  theme_box() %>%
  autofit()
ft
```

We used a Cox proportional hazards model stratified on team. The table shows the hazard ratios (HRs) and 95% confidence intervals (CIs).
Age increased the hazard of the first care directive, meaning it was associated with shorter times to the first care review. 

There were `r n_excluded_establishment` patients excluded as they were in the establishment phase. The total number of patients in the time-to-event model was `r format(nrow(for_model_care_review), big.mark=',')`. The number of patients not experiencing the outcome (censored or discharged) was `r sum(for_model_care_review$event_plus!= 'Yes')`. There were `r n_missing` patients excluded from the time-to-event analysis due to missing data.

##### Results per hospital (clinical-led discussion)

The results below are from separate Cox models in each hospital.

```{r}
all_ests_cox_care_review = all_res_cox_care_review = NULL
influence_cox_care_review = list()
for (hosp in c("X","Y",'Z')){
  ## Cox model stratified on team within hospital
  cox_model_care_review_hosp = coxph(Surv(time = time, event = event_plus == 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = filter(for_model_care_review, hospital==hosp))
  #
  ests = tidy(cox_model_care_review_hosp, conf.int = TRUE) %>%
    mutate(hospital = hosp)
  all_ests_cox_care_review = bind_rows(all_ests_cox_care_review, ests)
  ## use nicer names in facet labels for residuals/influential values
  varnames = names(cox_model_care_review_hosp$coefficients)
  names(cox_model_care_review_hosp$coefficients) = nice_rename(varnames)
  ## residuals for proportional hazards check
  res = data.frame(residuals(cox_model_care_review_hosp, type='schoenfeld')) 
  res$time = cox.zph(cox_model_care_review_hosp, transform='identity')$x # do not transform times
  row.names(res) = NULL
  res = pivot_longer(res, cols=-time, names_to = 'var', values_to='res') %>%
    mutate(time = as.numeric(time),
           hospital = hosp,
         var = nice_rename(var))
  all_res_cox_care_review = bind_rows(all_res_cox_care_review, res)
  ## influential values
  influence_cox_care_review[[hosp]] = ggcoxdiagnostics(fit=cox_model_care_review_hosp, sline=FALSE, type = 'dfbeta', linear.predictions = FALSE, point.shape = 1) + ggtitle(hosp) + xlab('Observation ID') 
}
# make the table of estimates
  nice_table = filter(all_ests_cox_care_review, !is.na(estimate)) %>%
  mutate(Variable = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    cell = paste(HR, ' (', conf.low, ' to ' , conf.high, ')', sep='')) %>%
  select(Variable, hospital, cell) %>%
  pivot_wider(values_from=cell, names_from=hospital) %>%
    select(Variable, X, Y, Z) # In intervention order
# table
ft = flextable(nice_table) %>%
  theme_box() %>%
  autofit()
ft
```

##### Results per hospital, excluding prior events (clinical-led discussion)

As a sensitivity analysis we repeat the survival analysis above, but exclude patients counted as "prior".

```{r}
all_ests_cox_care_review_no_prior = all_res_cox_care_review_no_prior = NULL
for (hosp in c("X","Y",'Z')){
  # exclude prior
  to_model = filter(for_model_care_review, 
                    event != 'Prior',
                    hospital == hosp)
  ## Cox model stratified on team within hospital
  cox_model_care_review_hosp_no_prior = coxph(Surv(time = time, event = event== 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = to_model)
  #
  ests = tidy(cox_model_care_review_hosp_no_prior, conf.int = TRUE) %>%
    mutate(hospital = hosp)
  all_ests_cox_care_review_no_prior = bind_rows(all_ests_cox_care_review_no_prior, ests)
  ## use nicer names in facet labels for residuals/influential values
  varnames = names(cox_model_care_review_hosp_no_prior$coefficients)
  names(cox_model_care_review_hosp_no_prior$coefficients) = nice_rename(varnames)
  ## residuals for proportional hazards check
  res = data.frame(residuals(cox_model_care_review_hosp_no_prior, type='schoenfeld')) 
  res$time = cox.zph(cox_model_care_review_hosp_no_prior, transform='identity')$x # do not transform times
  row.names(res) = NULL
  res = pivot_longer(res, cols=-time, names_to = 'var', values_to='res') %>%
    mutate(time = as.numeric(time),
           hospital = hosp,
         var = nice_rename(var))
  all_res_cox_care_review_no_prior = bind_rows(all_res_cox_care_review_no_prior, res)
}
# make the table of estimates
  nice_table = filter(all_ests_cox_care_review_no_prior, !is.na(estimate)) %>%
  mutate(Variable = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    cell = paste(HR, ' (', conf.low, ' to ' , conf.high, ')', sep='')) %>%
  select(Variable, hospital, cell) %>%
  pivot_wider(values_from=cell, names_from=hospital) %>%
    select(Variable, X, Y, Z) # In intervention order
# table
ft = flextable(nice_table) %>%
  theme_box() %>%
  autofit()
ft
```

##### Absolute measure of difference (clinical-led discussion)

We supplement the relative hazard ratios with an absolute measure of risk difference using the difference in the proportion who had a care review by day `r pred_time`. The confidence intervals for the difference are calculated using a bootstrap procedure with `r n_boot` bootstrap replications. The model adjusts for patient age, sex, CRiSTAL and SPICT score, and hence may not perfectly match the results from the above plots which are unadjusted. 

```{r}
# save results to save time
exists = length(dir('results', pattern = 'clinical_led_absolute_results.RData')) > 0
if(exists == FALSE){
  risk_difference_care_review = risk_diff_crr(
    indata = for_model_care_review,
    B = n_boot,
    pred_time = pred_time)
}
if(exists == TRUE){
  load('results/clinical_led_absolute_results.RData')
}
ftab = flextable(risk_difference_care_review) %>%
  theme_box() %>%
  autofit()
ftab
```

##### Absolute measure of difference by hospital (clinical-led discussion)

```{r}
# save results to save time
exists = length(dir('results', pattern = 'clinical_led_by_hospital_results.RData')) > 0
if(exists == FALSE){
  all_diffs_care_review = NULL
  for (hosp in c("X","Y",'Z')){
    risk_difference = risk_diff_crr(
      indata = filter(for_model_care_review, hospital==hosp),
      B = n_boot,
      pred_time = pred_time) %>%
      mutate(hospital = hosp)
    all_diffs_care_review = bind_rows(all_diffs_care_review, risk_difference)
  }
}
if(exists == TRUE){
  load('results/clinical_led_by_hospital_results.RData')
  all_diffs_care_review = mutate(all_diffs_care_review, hospital = deidentify_hospital(hospital)) # blind
}

#
for_table = mutate(all_diffs_care_review, cell = paste(Event, ' (', CI, ')', sep='')) %>%
  select(hospital, Phase, cell) %>%
  pivot_wider(names_from = hospital, values_from = cell) %>%
  select(Phase, X, Y, Z) # in intervention order
#
ftab = flextable(for_table) %>%
  theme_box() %>%
  autofit()
ftab
```


#### Time-to-event model checking (clinical-led discussion)

##### a) Baseline hazard

Here we plot the baseline hazard in each team. This is useful for checking the differences between hospitals. The plots are limited to the first `r pred_time` days. The teams and hospitals have been deidentified. 

```{r, fig.width=8}
base = basehaz(cox_model_care_review, centered=TRUE) %>%
  tidyr::separate(strata, into=c('hospital','team')) %>%
  mutate(hosp_ordered = factor(hospital, levels=c('X','Y','Z')))
# add team numbers to legend
counts = group_by(base, hospital, team) %>%
  tally() %>%
  mutate(team_number = paste(team, ' (', n, ')', sep=''))
base = left_join(base, counts, by=c('hospital','team'))
#
bplot = ggplot(data=base, aes(x=time, y=hazard, col=team_number)) +
  geom_line() +
  scale_color_hue('Team (number of patients)') +
#  scale_y_continuous(limits=c(0,1)) + # 
  #scale_x_continuous(limits=c(0,pred_time)) +
  coord_cartesian(xlim=c(0,pred_time))+ # limit based on censoring
  xlab('Time, days') +
  ylab('Cumulative hazard') +
  facet_wrap(~hosp_ordered) +
  g.theme
bplot
```


##### b) Proportional hazards assumption

Here we check the proportional hazards assumption for the Cox model. A non-proportional hazard would mean that the effect of a variable changed over time, e.g., age having a greater effect at longer times. The grey circles are the residuals and the green line is the smoothed residuals. If the hazards are proportional then this line will be flat. The red area is a 95% confidence interval for the smoothed line.

```{r, fig.height=7}
# ggcoxzph(cox.zph(cox_model_care_review, transform='identity'), se=FALSE) # check of my plot
x.times = c(0.01, 0.1, 1, 5, 10, 40) # times for x-axis
resplot = ggplot(data=all_res_cox_care_review, aes(x=log2(time), y=res)) +
  geom_hline(lty=2, yintercept = 0) +
  geom_point(col='grey77', shape=1) +
  scale_x_continuous(breaks=log2(x.times), labels=x.times) +
  geom_smooth(col='darkseagreen4', size=1.05, se=TRUE, method='loess', span=0.8, fill='red') +
  ylab('Schoenfeld residual') +
  xlab('Time from admission, days') +
  theme_bw() +
  facet_grid(var~hospital)
resplot
```

Because of the strong skew in times, we have log-transformed the x-axis.

##### c) Checking for influential patients

Here we check whether there are influential patients in the Cox time-to-event analysis. An influential patient is one who has a large effect of the estimates and hence any inference.

The plot below shows the 'dfbetas' which are the estimated changes in the regression coefficients after deleting each patient in turn. The y-axes show the estimate using all patients minus the estimate with a single patient removed. These plots are for model checking and will not be presented in papers or reports. 

```{r, fig.height=8, fig.width=9}
#
grid.arrange(influence_cox_care_review[['X']],
 influence_cox_care_review[['Y']],
 influence_cox_care_review[['Z']], ncol=1)
```

The x-axis of observation ID is the order in which patients were recruited over time. 

The apparent pattern in influential values for the intervention time is because of the ordering on the x-axis combined with a small difference in the influence of patients in the two treatment phases.

The scales on the y-axes are small and indicate little overall change in the estimates due to a single patient. 

###### page break

# Review of care directives documents

The results in this section only use the first care directive per patient. For patients without a review, we used their final completed form.

### Has there been a review of any care directives?

```{r}
# results split by hospital - change after unscrambling
stats = filter(survival_data_imputed[[1]], outcome== 'care_directive') %>%
  mutate(event = ifelse(event %in% c('No','Intervention','Post-intervention'), "Censored", event)) %>% # Added 31 Aug
  group_by(int_time, hospital, event) %>%
  tally()
stats2 = group_by(stats, hospital, int_time) %>%
  mutate(p = round(100*prop.table(n)),
         cell = paste(n, ' (', p, ')', sep='')) %>%
  select(-n, -p) %>%
  pivot_wider(names_from = event, values_from = cell)
# add totals 
totals = group_by(stats, hospital, int_time) %>%
  summarise(Total = sum(n),
            Total = paste(Total, ' (100)', sep=''))
#
to_table = left_join(stats2, totals, by=c('hospital','int_time')) %>%
  select(hospital, int_time, Censored, Discharge, Prior, Yes, Total) %>% # order rows 
  arrange(desc(hospital), int_time) %>%  # in order of intervention
  rename('Intervention time' = 'int_time') %>%
  mutate_all(zeros)
ftab = flextable(to_table) %>%
  theme_box() %>%
  merge_v(j=1) %>%
  autofit()
ftab
```

The table shows the number of patients and percentage in parentheses.

### What care directive review outcomes occurred?

There were eight outcomes and multiple outcomes could be ticked. The "Other" responses are too varied to summarise. 

##### Frequency table of care directive review outcomes (all hospitals combined)

```{r}
# make frame for later use
care_directive_types = filter(care_directive_imputed[[1]], change_5 == 'Yes') %>%
  select(participant_id, int_time, starts_with('type_care_')) %>%
  tidyr::gather(key='num', value='checked', -participant_id, -int_time) %>%
  mutate(Action = nice.rename.directive(num),
         num = as.numeric(str_remove_all(num, '[^0-9]')),
         numf = factor(num, levels=1:8, labels=care_directives), 
         checked = factor(checked, levels=c('Checked','Unchecked'), labels=c('Yes','No'))) %>%
  unique() # just one per patient and outcome
counts = group_by(care_directive_types, int_time, Action, checked) %>%
  tally() %>%
  group_by(int_time, Action) %>%
  mutate(percent = round(100*prop.table(n)),
         cell = paste(n, ' (', percent, ')', sep=''))
counts_wide = select(counts, -n, -percent) %>%
  pivot_wider(names_from=c(int_time, checked), values_from=cell)
# order from high to low
overall = filter(care_directive_types, checked== 'Yes') %>%
  group_by(Action) %>%
  tally() %>%
  ungroup() %>%
  arrange(desc(n)) %>% # high to low
  mutate(x = 1:n())
for.table = left_join(counts_wide, overall, by='Action') %>%
  arrange(x) %>%
  select(-x, -n)
# header
typology <- data.frame(
  col_keys = c( "Action", "Usual care_Yes", "Usual care_No", "Establishment_Yes", "Establishment_No",
                "Intervention_Yes", "Intervention_No"),
  what = c(" ", "Usual care", "Usual care", "Establishment", "Establishment", "Intervention", "Intervention"),
  measure = c("Action", "Yes", "No", "Yes", "No", "Yes", "No"),
  stringsAsFactors = FALSE )
#
ftab = flextable(for.table) %>%
  set_header_df(mapping = typology, key = "col_keys" ) %>%
  #merge_v(j=1) %>%
  merge_h(part = "header") %>%
  theme_box() %>%
  fontsize(size=8, part='all') %>%
  width(width = c(1.8,1,1,1,1,1,1))
ftab
```

The table shows the number of patients and percentage in parentheses. The table rows are ordered by frequency. The "Other" actions are too varied to summarise. 

##### Bar plot of care directive review outcomes (all hospitals combined)

```{r, fig.width=8, fig.height=7}
for.plot = left_join(counts, overall, by='Action') 
labels = overall$Action # 
stack = ggplot(data=for.plot, aes(x=x, y=percent, fill=checked)) +
  geom_bar(position='stack', stat='identity') +
  g.theme+
  theme(legend.position='top')+
  scale_x_reverse(breaks=1:length(labels), labels=labels)+ # reverse to keep same order as table
  scale_fill_manual(NULL, values=c("cadetblue3","orange2")) +
  coord_flip() +
  xlab('') +
  ylab('Percent of patients') +
  facet_wrap(~int_time)
stack
```

The plot results are ordered by frequency.

##### Upset plot of care directive review outcome combinations

Multiple options could be ticked for the care review outcomes, meaning that patients could have combinations of outcomes from a care directive review. 
The plots below shows the top ten combinations split by intervention phase for all hospitals combined. We only plot results for patients who had a care directive review. 

```{r, fig.width=7, fig.height=9}
## get combinations of yes responses
# had to split by intervention time because of strange deal with NA
# a) usual care
yes_responses_uc <- filter(care_directive_imputed[[1]], 
         int_time  == 'Usual care', 
         change_5 == 'Yes') %>% # only where there's some care directive
  dplyr::select(participant_id, starts_with('type_care_directive'))  %>%
  as_tibble() %>%
  tidyr::gather(key='outcome', value='response', -participant_id) %>%
  filter(response== 'Checked') %>% # just yes
  select(-response) %>%
  mutate(outcome = nice.rename.directive(outcome)) %>%
  ungroup()
# now make list from group responses
list_resp_uc = group_by(yes_responses_uc, participant_id) %>%
  summarise(outcomes = list(outcome)) %>%
  ungroup()
# add zeros
all_ids_uc = filter(care_directive_imputed[[1]], 
                 int_time == 'Usual care',
                 change_5 == 'Yes') %>% pull(participant_id)
missing.ids = all_ids_uc[all_ids_uc %in% list_resp_uc$participant_id == FALSE]
zeros_uc = as_tibble(data.frame(participant_id = missing.ids))
list_resp_uc = bind_rows(list_resp_uc, zeros_uc) 
# plot
cplot_uc = ggplot(list_resp_uc, aes(x = outcomes)) +
    geom_bar(aes(y=..count../sum(..count..)), fill = "darkseagreen4") +
    g.theme +
  ggtitle("Usual care") +
    xlab("") +
    scale_x_upset(n_intersections = 10) + # top ten
    ylab("Proportion of patients")
# b) intervention
yes_responses_int <- filter(care_directive_imputed[[1]], 
                           int_time  == 'Intervention', 
                           change_5 == 'Yes') %>% # only where there's some care directive
  dplyr::select(participant_id, starts_with('type_care_directive'))  %>%
  as_tibble() %>%
  tidyr::gather(key='outcome', value='response', -participant_id) %>%
  filter(response== 'Checked') %>% # just yes
  select(-response) %>%
  mutate(outcome = nice.rename.directive(outcome)) %>%
  ungroup()
# now make list from group responses
list_resp_int = group_by(yes_responses_int, participant_id) %>%
  summarise(outcomes = list(outcome)) %>%
  ungroup()
# add zeros
all_ids_int = filter(care_directive_imputed[[1]], 
                    int_time == 'Intervention',
                    change_5 == 'Yes') %>% pull(participant_id)
missing.ids = all_ids_int[all_ids_int %in% list_resp_int$participant_id == FALSE]
zeros_int = as_tibble(data.frame(participant_id = missing.ids))
list_resp_int = bind_rows(list_resp_int, zeros_int) 
# plot
cplot_int = ggplot(list_resp_int, aes(x = outcomes)) +
  geom_bar(aes(y=..count../sum(..count..)), fill = "darkseagreen4") +
  g.theme +
  xlab("") +
  ggtitle("Intervention") +
  scale_x_upset(n_intersections = 10) + # top ten
  ylab("Proportion of patients")
# grid 
grid.arrange(cplot_uc, cplot_int, nrow=2)
```

### Days and times when care directive reviews took place

```{r, out.width='100%'}
to_plot = circular_plots(indata = care_directive_imputed[[1]], 
                         var = 'change_5', # outcome
                         datetime = 'date_time_5',  # time of outcome
                         blind = TRUE)
print(to_plot$week)
```

The results are standardised to the numbers per week because the hospitals had different times in the usual care and intervention phases.

There are `r to_plot$missing_hour` patients (`r to_plot$missing_hour_percent` %) that were missing the time the review took place and are not included in these plots.

```{r, out.width='100%'}
print(to_plot$hour)
```


### Have the completed care directive document/s been uploaded to 'tracker'?

```{r, results='asis'}
stats = filter(care_directive_imputed[[1]], change_5 == 'Yes') %>% # change_5 is event
  tabyl(int_time, tracker) %>%
  adorn_totals("col") %>%
  tidyr::gather(tracker, n, 2:ncol(.), convert = TRUE) %>%
  group_by(int_time) %>%
  mutate(p = round(100*prop.table(n)),
         p = p*2, # because total is in calculations
         cell = paste(n, ' (', p, ')', sep='')) %>%
  select(-n, -p) %>%
  pivot_wider(names_from = tracker, values_from=cell) %>%
  rename('Intervention time' = 'int_time',
         'Missing' = 'NA_')
ftab = flextable(stats) %>%
  theme_box() %>%
  autofit()
ftab
```

The above table is only for patients with a care directive. The cells show the numbers and percentages in parentheses.  

### Time-to-event analysis of time from ward admission to first review of care directive documents

Here we use survival analysis to examine the time to the first care directive measure. The plot below shows the cumulative probability for the first care directive measure by intervention phase.

```{r, include=FALSE}
## prepare data for cumulative and instantaneous survival models
for_model_care_directive = list()
for (k in 1:10){ # loop through imputations
for_model_care_directive[[k]] = filter(survival_data_imputed[[k]],
                  outcome == 'care_directive',
                  int_time != 'Establishment') %>% # excluded from analysis
  # add prior events as events at early time
  mutate(event = as.character(event), # needed for ifelse below
         event = ifelse(event== 'No', 'Censored', event), # change "No" to "censored" for this analysis. Competing risks are death/discharge
         event_plus = event,
         event_plus = ifelse(event=='Prior', 'Yes', event_plus)) # prior counted as early event

# add variables from baseline data
for_model_care_directive[[k]] = left_join(for_model_care_directive[[k]], data_to_add, by='participant_id')
} # end of imputation loop

## numbers excluded
# a) establishment
n_excluded_establishment = nrow(filter(survival_data_imputed[[1]], # can use any imputation
                               outcome == 'care_directive',
                               int_time == 'Establishment'))
```


##### Cumulative probability plot (care directive review)

```{r, fig.width=7}
## cumulative probability plot
# plot in each hospital - change after scrambling
plot_data = NULL
for (hosp in c('X','Y','Z')){
  this_data = filter(for_model_care_directive[[1]], hospital ==hosp) %>%
    mutate(
      int_timec = as.character(int_time),
      int_timec = ifelse(int_timec=='Usual care', 'UsualCare', int_timec), # ggcompetingrisks cannot handle spaces
      event = ifelse(event=='Prior', 'Yes', event), # prior count as events at early time
      eventSimple = case_when(
           event == 'Intervention' ~ 'Censored',
           event == 'Post-intervention' ~ 'Censored',
           event == 'No' ~ 'Censored',
           TRUE ~ as.character(event)
      )) 
  cum_inc = with(this_data, cuminc(ftime=time, fstatus=eventSimple, group=int_timec, cencode='Censored'))
  g = ggcompetingrisks(cum_inc,
                       xlab = 'Days',
                       ylab = 'Cumulative probability',
                       multiple_panels = FALSE,
                       title = '',
                       cumcensor = TRUE, # does not work
                       legend.title='',
                       risk.table = TRUE, # does not work
                       conf_int = TRUE) # does not work
  # combine data
  this_plot = mutate(g$data, hospital=hosp)
  plot_data = bind_rows(plot_data, this_plot)
}
# add CI
to_plot_care_directive = mutate(plot_data,
                 hosp_ordered = factor(hospital, levels=c('X','Y','Z')), # to show in intervention order
                 z = qnorm(0.975),
                 lower  = est - (z*sqrt(var)),
                 upper  = est + (z*sqrt(var)),
                 group = ifelse(group=='Usual', 'Usual care', group))
# redo plot for greater control
alt_plot = ggplot(to_plot_care_directive, aes(x=time, y=est, ymin=lower, ymax=upper, linetype=event, col=group)) +
#  geom_ribbon(alpha=0.2) + # too busy
  geom_line(size = 1.05) +  # make lines thicker
  scale_y_continuous(limits=c(0,1)) + # 
  coord_cartesian(xlim=c(0,pred_time))+ # limit based on censoring
  theme_bw() +
  scale_color_manual(NULL, values=cbPalette, labels=c('Intervention', 'Usual care')) +
  scale_linetype_manual(NULL, values=c(2,1), labels=c('Discharge/Death','Outcome')) +
  xlab('Days from ward admission') +
  ylab('Cumulative probability') +
  theme(legend.position = 'right',
        panel.grid.minor = element_blank()) +
  facet_wrap(~hosp_ordered)
alt_plot

# for text, number of events post cut-off
n_after = sum(for_model_care_directive[[1]]$time > pred_time)
percent_after = round(100*n_after / nrow(for_model_care_directive[[1]]))
post_cutoff = paste(n_after, ' (', percent_after, '%)', sep='')
```

We limited the plot to the first `r pred_time` days because there were only `r post_cutoff` events after this time.

Note the y-axis upper limit was set below 1 to reduce white space. 

##### Cox time-to-event model of time to care directive review

```{r, include=FALSE}
# Cox model stratified on team within hospital
vars = parms = cox_model_care_directive = list()
for (k in 1:10){ # loop through imputations
  # add prior events as events at early time
  for_model_care_directive[[k]] = mutate(for_model_care_directive[[k]])
  cox_model_care_directive[[k]] = coxph(Surv(time = time, event = event_plus== 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = for_model_care_directive[[k]])
  parms[[k]] =  coefficients(cox_model_care_directive[[k]])
  vars[[k]] =  vcov(cox_model_care_directive[[k]])
}
# number missing:
n_missing = nrow(for_model_care_directive[[1]]) - cox_model_care_directive[[1]]$n
# combine imputations
ests_raw = MIcombine(results=parms, variances=vars)
ests = print(ests_raw) %>%
  rename('estimate' = 'results') %>%
  mutate(term = names(parms[[1]]),
         Variable = nice_rename(term), # see 99_functions
         z = qnorm(0.975),
         conf.low = estimate - (z*se),
         conf.high = estimate + (z*se),
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    CI = paste(conf.low, ' to ' , conf.high, sep='')) %>%
  select(Variable, HR, CI)
```

```{r}
ft = flextable(ests) %>%
  theme_box() %>%
  autofit()
ft
```

We used a Cox proportional hazards model stratified on team. The table shows the hazard ratios (HRs) and 95% confidence intervals (CIs).
Age increased the hazard of the first care directive, meaning it was associated with shorter times to the first clinician-led review. 

These results combine ten models fitted to imputed data because of some missing data for existing ARPs. The ten data sets were imputed using a multinomial model (details in a separate report). 

There were `r n_excluded_establishment` patients excluded as they were in the establishment phase. The total number of patients in the time-to-event model was `r format(nrow(for_model_care_directive[[1]]), big.mark=',')`. The number of patients not experiencing the outcome (censored or discharged) was `r sum(for_model_care_directive[[1]]$event_plus!= 'Yes')`. There were `r n_missing` patients excluded from the time-to-event analysis due to missing data.

##### Results per hospital (care directive review)

The results below are from separate Cox models in each hospital.

```{r, include=FALSE}
all_ests_cox_care_directive = all_res_cox_care_directive = NULL
influence_cox_care_directive = list()
for (hosp in c("X","Y",'Z')){
  vars = parms = cox_model_care_directive_hosp = list()
for (k in 1:10){ # loop through imputations
  cox_model_care_directive_hosp[[k]] = coxph(Surv(time = time, event = event_plus== 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = filter(for_model_care_directive[[k]], hospital==hosp))
  #
  parms[[k]] =  coefficients(cox_model_care_directive_hosp[[k]])
  vars[[k]] =  vcov(cox_model_care_directive_hosp[[k]])
}
  # combine imputations
  ests_raw = MIcombine(results=parms, variances=vars)
  ests = print(ests_raw) %>%
    mutate(term = names(parms[[1]]),
         hospital = hosp)
  all_ests_cox_care_directive = bind_rows(all_ests_cox_care_directive, ests)
  ## use nicer names in facet labels for residuals/influential values
  varnames = names(cox_model_care_directive_hosp[[k]]$coefficients)
  names(cox_model_care_directive_hosp[[k]]$coefficients) = nice_rename(varnames)
  # residuals for proportional hazards check
  res = data.frame(residuals(cox_model_care_directive_hosp[[k]], type='schoenfeld')) 
  res$time = cox.zph(cox_model_care_directive_hosp[[k]], transform='identity')$x # do not transform times
  row.names(res) = NULL
  res = pivot_longer(res, cols=-time, names_to = 'var', values_to='res') %>%
    mutate(time = as.numeric(time),
           hospital = hosp,
         var = nice_rename(var))
  all_res_cox_care_directive = bind_rows(all_res_cox_care_directive, res)
  ## influential values
  influence_cox_care_directive[[hosp]] = ggcoxdiagnostics(fit=cox_model_care_directive_hosp[[k]], sline=FALSE, type = 'dfbeta', linear.predictions = FALSE, point.shape = 1) + ggtitle(hosp) + xlab('Observation ID') 
} # end of hospital loop
# make nice table
  all_ests_cox_care_directive = rename(all_ests_cox_care_directive, 'estimate' = 'results') %>%
     mutate(Variable = nice_rename(term), # see 99_functions
         z = qnorm(0.975),
         conf.low = estimate - (z*se),
         conf.high = estimate + (z*se))
  nice_table = mutate(all_ests_cox_care_directive,
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
   cell = paste(HR, ' (', conf.low, ' to ' , conf.high, ')', sep='')) %>%
  select(Variable, hospital, cell) %>%
  pivot_wider(values_from=cell, names_from=hospital) %>%
    select(Variable, X, Y, Z) # In intervention order
```
  
```{r}  
ft = flextable(nice_table) %>%
  theme_box() %>%
  autofit()
ft
```

##### Results per hospital, excluding prior events (care directive review)

As a sensitivity analysis we repeat the survival analysis above, but exclude patients counted as "prior".

```{r, include=FALSE}
all_ests_cox_care_directive_no_prior = all_res_cox_care_directive_no_prior = NULL
for (hosp in c("X","Y",'Z')){
    vars = parms = cox_model_care_directive_hosp_no_prior = list()
for (k in 1:10){ # loop through imputations
# exclude prior
  to_model = filter(for_model_care_directive[[k]], 
                    event != 'Prior',
                    hospital == hosp)
  ## Cox model stratified on team within hospital
  cox_model_care_directive_hosp_no_prior[[k]] = coxph(Surv(time = time, event = event== 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = to_model)
    parms[[k]] =  coefficients(cox_model_care_directive_hosp_no_prior[[k]])
  vars[[k]] =  vcov(cox_model_care_directive_hosp_no_prior[[k]])
}
  # combine imputations
  ests_raw = MIcombine(results=parms, variances=vars)
  ests = print(ests_raw) %>%
    mutate(term = names(parms[[1]]),
         hospital = hosp)
  all_ests_cox_care_directive_no_prior = bind_rows(all_ests_cox_care_directive_no_prior, ests)
  ## use nicer names in facet labels for residuals/influential values
  varnames = names(cox_model_care_directive_hosp_no_prior[[k]]$coefficients)
  names(cox_model_care_directive_hosp_no_prior[[k]]$coefficients) = nice_rename(varnames)
  ## residuals for proportional hazards check
  res = data.frame(residuals(cox_model_care_directive_hosp_no_prior[[k]], type='schoenfeld')) 
  res$time = cox.zph(cox_model_care_directive_hosp_no_prior[[k]], transform='identity')$x # do not transform times
  row.names(res) = NULL
  res = pivot_longer(res, cols=-time, names_to = 'var', values_to='res') %>%
    mutate(time = as.numeric(time),
           hospital = hosp,
           var = nice_rename(var))
  all_res_cox_care_directive_no_prior = bind_rows(all_res_cox_care_directive_no_prior, res)
}
# make table
  all_ests_cox_care_directive_no_prior = rename(all_ests_cox_care_directive_no_prior, 'estimate' = 'results') %>%
         mutate(Variable = nice_rename(term), # see 99_functions
         z = qnorm(0.975),
         conf.low = estimate - (z*se),
         conf.high = estimate + (z*se))
  nice_table = mutate(all_ests_cox_care_directive_no_prior,
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
   cell = paste(HR, ' (', conf.low, ' to ' , conf.high, ')', sep='')) %>%
  select(Variable, hospital, cell) %>%
  pivot_wider(values_from=cell, names_from=hospital) %>%
    select(Variable, X, Y, Z) # In intervention order
```
  
```{r}  
ft = flextable(nice_table) %>%
  theme_box() %>%
  autofit()
ft
```


##### Absolute measure of difference (care directive review)

We supplement the hazard ratios with an absolute measure of risk difference using the difference in the proportion who had a care directive measure by day `r pred_time`.

```{r}
# save results to save time
exists = length(dir('results', pattern = 'care_directive_absolute_results.RData')) > 0
if(exists == FALSE){
  risk_difference_care_directive = risk_diff_crr(
    indata = for_model_care_directive[[1]],
    B = n_boot,
    pred_time = pred_time)
}
if(exists == TRUE){load('results/care_directive_absolute_results.RData')}
# table
ftab = flextable(risk_difference_care_directive) %>%
  theme_box() %>%
  autofit()
ftab
```

##### Absolute measure of difference by hospital (care directive review)

```{r}
# save results to save time
exists = length(dir('results', pattern = 'care_directive_absolute_by_hospital_results.RData')) > 0
if(exists == FALSE){
  all_diffs_care_directive = NULL
  for (hosp in c("X","Y",'Z')){
    risk_difference = risk_diff_crr(
      indata = filter(for_model_care_directive[[1]], hospital==hosp),
      B = n_boot,
      pred_time = pred_time) %>%
      mutate(hospital = hosp)
    all_diffs_care_directive = bind_rows(all_diffs_care_directive, risk_difference)
  }
}
if(exists == TRUE){
  load('results/care_directive_absolute_by_hospital_results.RData')
  all_diffs_care_directive = mutate(all_diffs_care_directive, hospital = deidentify_hospital(hospital))
}
# table
for_table = mutate(all_diffs_care_directive, cell = paste(Event, ' (', CI, ')', sep='')) %>%
  select(hospital, Phase, cell) %>%
  pivot_wider(names_from = hospital, values_from = cell) %>%
  select(Phase, X, Y, Z) # in intervention order
#
ftab = flextable(for_table) %>%
  theme_box() %>%
  autofit()
ftab
```



#### Time-to-event model checking (care directive review)

##### a) Baseline hazard

Here we plot the baseline hazard in each team. This is useful for checking the differences between hospitals. The plots are limited to the first `r pred_time` days. 

```{r, fig.width=8}
base = basehaz(cox_model_care_directive[[1]], centered=TRUE) %>%
  tidyr::separate(strata, into=c('hospital','team')) %>%
  mutate(hosp_ordered = factor(hospital, levels=c())) # 
# add team numbers to legend
counts = group_by(base, hospital, team) %>%
  tally() %>%
  mutate(team_number = paste(team, ' (', n, ')', sep=''))
base = left_join(base, counts, by=c('hospital','team'))
#
bplot = ggplot(data=base, aes(x=time, y=hazard, col=team_number)) +
  geom_line() +
  scale_color_hue('Team (number of patients)') +
 # scale_x_continuous(limits=c(0,pred_time)) +
  coord_cartesian(xlim=c(0,pred_time))+ # limit based on censoring
  xlab('Time, days') +
  ylab('Cumulative hazard') +
  facet_wrap(~hosp_ordered) +
  g.theme
bplot
```


##### b) Proportional hazards assumption

Here we check the proportional hazards assumption for the Cox model. A non-proportional hazard would mean that the effect of a variable changed over time, e.g., age having a greater effect at longer times. The grey circles are the residuals and the green line is the smoothed residuals. If the hazards are proportional then this line will be flat. The red shaded area is a 95% confidence interval for the smoothed line.

```{r, fig.height=7}
x.times = c(0.01, 0.1, 1, 5, 10, 40) # times for x-axis
resplot = ggplot(data=all_res_cox_care_directive, aes(x=log2(time), y=res)) +
  geom_hline(lty=2, yintercept = 0) +
  geom_point(col='grey88', shape=1) +
  scale_x_continuous(breaks=log2(x.times), labels=x.times) +
  geom_smooth(col='darkseagreen4', size=1.05, se=TRUE, method='loess', span=0.8, fill='red') +
  ylab('Schoenfeld residual') +
  xlab('Time from admission, days') +
  theme_bw() +
  facet_grid(var~hospital)
resplot
```

The scales on the y-axis are different. Because of the strong skew in times, we have log-transformed the x-axis of the plot.

There is some evidence of non-proportional hazards for age. An older age may have a stronger effect early in the admission. 

##### c) Checking for influential patients

Here we check whether there are influential patients in the Cox time-to-event analysis. An influential patient is one who has a large effect of the estimates and hence any inference.

The plot below shows the 'dfbetas' which are the estimated changes in the regression coefficients after deleting each observation patient in turn. 

```{r, fig.height=8, fig.width=9}
#
grid.arrange(influence_cox_care_directive[['X']],
 influence_cox_care_directive[['Y']],
 influence_cox_care_directive[['Z']], ncol=1)
```

The x-axis of observation ID is the order in which patients were recruited over time. 

The apparent pattern in influential values for the intervention time is because of the ordering on the x-axis combined with a small difference in the influence of patients in the two treatment phases.


###### page break

# Palliative care referral

The results in this section only use the first palliative care referral per patient, or for patients without any referrals in their completed forms.

### Has this patient been referred to palliative care?

```{r}
# results split by hospital - change after unscrambling
stats = filter(survival_data, outcome== 'palliative_care_referral') %>%
  mutate(event = ifelse(event %in% c('No','Intervention','Post-intervention'), "Censored", event)) %>% # Added August
  group_by(int_time, hospital, event) %>%
  tally()
stats2 = group_by(stats, hospital, int_time) %>%
  mutate(p = round(100*prop.table(n)),
         cell = paste(n, ' (', p, ')', sep='')) %>%
  select(-n, -p) %>%
  pivot_wider(names_from = event, values_from = cell)
# add totals 
totals = group_by(stats, hospital, int_time) %>%
  summarise(Total = sum(n),
            Total = paste(Total, ' (100)', sep=''))
#
to_table = left_join(stats2, totals, by=c('hospital','int_time')) %>%
  select(hospital, int_time, Censored, Discharge, Prior, Yes, Total) %>% # order rows
  arrange(hospital, int_time) %>%
  rename('Intervention time' = 'int_time') %>%
  mutate_all(zeros)
ftab = flextable(to_table) %>%
  theme_box() %>%
  merge_v(j=1) %>%
  autofit()
ftab
```


### Days and times when referral took place

```{r, out.width='100%'}
to_plot = circular_plots(palliative_care_referral,
                         var = 'pall_care',
                         datetime = 'pall_date',
                         blind = TRUE)
print(to_plot$week)
```

There are `r to_plot$missing_hour` patients (`r to_plot$missing_hour_percent` %) that were missing the time the referral took place and are not included in these plots.

The majority of referrals happened in the morning. Few referrals were made on Fridays or weekends.

```{r, out.width='100%'}
print(to_plot$hour)
```


### Time-to-event analysis of time from ward admission to first palliative care referral 

Here we use time-to-event analysis to examine the time to the first palliative care referral. The plot below shows the cumulative probability for the first palliative care referral by intervention phase.

```{r, include=FALSE}
## prepare data for cumulative and instantaneous survival models
# exclude prior:
for_model_palliative = filter(survival_data,
                  outcome == 'palliative_care_referral',
                  int_time != 'Establishment') %>% # excluded from analysis
  mutate(event = as.character(event), # needed for ifelse below
         event_plus = event,
         event_plus = ifelse(event== 'Prior', 'Yes', event_plus), # prior to early yes
         event = ifelse(event== 'No', 'Censored', event)) # change "No" to "censored" for this analysis. Competing risks are death/discharge

# add variables from baseline data (age, sex)
for_model_palliative = left_join(for_model_palliative, data_to_add, by='participant_id')

## numbers excluded
# a) establishment
n_excluded_establishment = nrow(filter(survival_data, 
                               outcome == 'palliative_care_referral',
                               int_time == 'Establishment'))
```

##### Cumulative probability plot (palliative care referral)

```{r, fig.width=7}
## cumulative probability plot
# plot in each hospital - change after scrambling
plot_data = NULL
for (hosp in c('X','Y','Z')){
  this_data = filter(for_model_palliative, hospital ==hosp) %>%
    mutate(int_timec = as.character(int_time),
      int_timec = ifelse(int_timec=='Usual care', 'UsualCare', int_timec), # ggcompetingrisks cannot handle spaces
      event = ifelse(event=='Prior', 'Yes', event), # prior count as events at early time
      eventSimple = case_when(
           event == 'Intervention' ~ 'Censored',
           event == 'Post-intervention' ~ 'Censored',
           event == 'No' ~ 'Censored',
           TRUE ~ as.character(event)
      ))
  cum_inc = with(this_data, cuminc(ftime=time, fstatus=eventSimple, group=int_timec, cencode='Censored'))
  g = ggcompetingrisks(cum_inc,
                       xlab = 'Days',
                       ylab = 'Cumulative probability',
                       multiple_panels = FALSE,
                       title = '',
                       cumcensor = TRUE, # does not work
                       legend.title='',
                       risk.table = TRUE, # does not work
                       conf_int = TRUE) # does not work
  # combine data
  this_plot = mutate(g$data, hospital=hosp)
  plot_data = bind_rows(plot_data, this_plot)
}
# add CI
to_plot_palliative = mutate(plot_data,
                 hosp_ordered = factor(hospital, levels=c('X','Y','Z')), # to show in intervention order
                 z = qnorm(0.975),
                 lower  = est - (z*sqrt(var)),
                 upper  = est + (z*sqrt(var)),
                 group = ifelse(group=='Usual', 'Usual care', group))
# redo plot for greater control
alt_plot = ggplot(to_plot_palliative, aes(x=time, y=est, ymin=lower, ymax=upper, linetype=event, col=group)) +
#  geom_ribbon(alpha=0.2) + # too busy
  geom_line(size = 1.05) +  # make lines thicker
  scale_y_continuous(limits=c(0,1)) + # 
  coord_cartesian(xlim=c(0,pred_time))+ # limit based on censoring
  theme_bw() +
  scale_color_manual(NULL, values=cbPalette, labels=c('Intervention', 'Usual care')) +
  scale_linetype_manual(NULL, values=c(2,1), labels=c('Discharge/Death','Outcome')) +
  xlab('Days from ward admission') +
  ylab('Cumulative probability') +
  theme(legend.position = 'right',
        panel.grid.minor = element_blank()) +
  facet_wrap(~hosp_ordered)
alt_plot

# for text, number of events post cut-off
n_after = sum(for_model_palliative$time > pred_time)
percent_after = round(100*n_after / nrow(for_model_palliative))
post_cutoff = paste(n_after, ' (', percent_after, '%)', sep='')
```

We limited the plot to the first `r pred_time` days because there were only `r post_cutoff` events after this time.

Note the y-axis upper limit was set below 1 due to the relatively small number of events.

##### Cox time-to-event model of time to first palliative care referral

```{r}
# Cox model stratified on team within hospital
cox_model_palliative = coxph(Surv(time = time, event = event_plus== 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = for_model_palliative)
# number missing:
n_missing = nrow(for_model_palliative) - cox_model_palliative$n
# table
ests = tidy(cox_model_palliative, conf.int = TRUE) %>%
  filter(!is.na(estimate)) %>%
  mutate(
    Variable = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    CI = paste(conf.low, ' to ' , conf.high, sep='')) %>%
  select(Variable, HR, CI)
ft = flextable(ests) %>%
  theme_box() %>%
  autofit()
ft
```

Older age had a higher hazard ratio meaning a shorter time to palliative care referral. Women had a hazard ratio below one, meaning a longer time to palliative care referral. 


There were `r n_excluded_establishment` patients were excluded as they were in the establishment phase. The total number of patients in the time-to-event model was `r format(nrow(for_model_palliative), big.mark=',')`. The number of patients not experiencing the outcome (censored or discharged) was `r sum(for_model_palliative$event_plus!= 'Yes')`. There were `r n_missing` patients excluded from the time-to-event analysis due to missing data.

##### Results per hospital

The results below are from separate Cox models in each hospital.

```{r}
all_ests_cox_palliative = all_res_cox_palliative = NULL
influence_cox_palliative = list()
for (hosp in c('X','Y','Z')){
  # Cox model stratified on team within hospital
  cox_model_palliative_hosp = coxph(Surv(time = time, event = event_plus== 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = filter(for_model_palliative, hospital==hosp))
  #
  ests = tidy(cox_model_palliative_hosp, conf.int = TRUE) %>%
    mutate(hospital = hosp)
  all_ests_cox_palliative = bind_rows(all_ests_cox_palliative, ests)
   ## use nicer names in facet labels for residuals/influential values
  varnames = names(cox_model_palliative_hosp$coefficients)
  names(cox_model_palliative_hosp$coefficients) = nice_rename(varnames)
# residuals for proportional hazards check
  res = data.frame(residuals(cox_model_palliative_hosp, type='schoenfeld')) 
  res$time = cox.zph(cox_model_palliative_hosp, transform='identity')$x # do not transform times
  row.names(res) = NULL
  res = pivot_longer(res, cols=-time, names_to = 'var', values_to='res') %>%
    mutate(time = as.numeric(time),
           hospital = hosp,
         var = nice_rename(var))
  all_res_cox_palliative = bind_rows(all_res_cox_palliative, res)
  ## influential values
  influence_cox_palliative[[hosp]] = ggcoxdiagnostics(fit=cox_model_palliative_hosp, sline=FALSE, type = 'dfbeta', linear.predictions = FALSE, point.shape = 1) + ggtitle(hosp) + xlab('Observation ID') 
} # end of hospital loop
# make table
  nice_table = filter(all_ests_cox_palliative, !is.na(estimate)) %>%
  mutate(Variable = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    cell = paste(HR, ' (', conf.low, ' to ' , conf.high, ')', sep='')) %>%
  select(Variable, hospital, cell) %>%
  pivot_wider(values_from=cell, names_from=hospital) %>%
    select(Variable, X, Y, Z) # In intervention order
ft = flextable(nice_table) %>%
  theme_box() %>%
  autofit()
ft
```

##### Results per hospital, excluding prior events (palliative care referral)

As a sensitivity analysis we repeat the survival analysis above, but exclude patients counted as "prior".

```{r}
all_ests_cox_palliative_no_prior = all_res_cox_palliative_no_prior = NULL
for (hosp in c('X','Y','Z')){
  # exclude prior
  to_model = filter(for_model_palliative, 
                    event != 'Prior',
                    hospital == hosp)
  ## Cox model stratified on team within hospital
  cox_model_palliative_hosp_no_prior = coxph(Surv(time = time, event = event== 'Yes') ~ int_time_n + I(age/5) + pt_sex +  cristal_score + spict_score + strata(team), data = to_model)
  #
  ests = tidy(cox_model_palliative_hosp_no_prior, conf.int = TRUE) %>%
    mutate(hospital = hosp)
  all_ests_cox_palliative_no_prior = bind_rows(all_ests_cox_palliative_no_prior, ests)
  ## use nicer names in facet labels for residuals/influential values
  varnames = names(cox_model_palliative_hosp_no_prior$coefficients)
  names(cox_model_palliative_hosp_no_prior$coefficients) = nice_rename(varnames)
  ## residuals for proportional hazards check
  res = data.frame(residuals(cox_model_palliative_hosp_no_prior, type='schoenfeld')) 
  res$time = cox.zph(cox_model_palliative_hosp_no_prior, transform='identity')$x # do not transform times
  row.names(res) = NULL
  res = pivot_longer(res, cols=-time, names_to = 'var', values_to='res') %>%
    mutate(time = as.numeric(time),
           hospital = hosp,
           var = nice_rename(var))
  all_res_cox_palliative_no_prior = bind_rows(all_res_cox_palliative_no_prior, res)
}
# make the table of estimates
nice_table = filter(all_ests_cox_palliative_no_prior, !is.na(estimate)) %>%
  mutate(Variable = nice_rename(term), # see 99_functions
         HR = roundz(exp(estimate),2),
         conf.low = roundz(exp(conf.low),2),
         conf.high = roundz(exp(conf.high),2),
         cell = paste(HR, ' (', conf.low, ' to ' , conf.high, ')', sep='')) %>%
  select(Variable, hospital, cell) %>%
  pivot_wider(values_from=cell, names_from=hospital) %>%
  select(Variable, X, Y, Z) # In intervention order
# table
ft = flextable(nice_table) %>%
  theme_box() %>%
  autofit()
ft
```


##### Absolute measure of difference (palliative care referral)

We supplement the hazard ratios with an absolute measure of risk difference using the difference in the proportion who had been referred to palliative care by day `r pred_time`.

```{r}
# save results to save time
exists = length(dir('results', pattern = 'palliative_absolute_results.RData')) > 0
if(exists == FALSE){
  risk_difference_palliative = risk_diff_crr(
    indata = for_model_palliative,
    dp = 3, # extra decimal place due to proportions under 0.10
    B = n_boot,
    pred_time = pred_time)
}
if(exists == TRUE){load('results/palliative_absolute_results.RData')}
# table
ftab = flextable(risk_difference_palliative) %>%
  theme_box() %>%
  autofit()
ftab
```


##### Absolute measure of difference by hospital (palliative care referral)

```{r}
exists = length(dir('results', pattern = 'palliative_absolute_by_hospital_results.RData')) > 0
if(exists == FALSE){
  all_diffs_palliative = NULL
  for (hosp in c('X','Y','Z')){
    risk_difference = risk_diff_crr(
      indata = filter(for_model_palliative, hospital==hosp),
      B = n_boot,
      pred_time = pred_time) %>%
      mutate(hospital = hosp)
    all_diffs_palliative = bind_rows(all_diffs_palliative, risk_difference)
  }
}
if(exists == TRUE){
  load('results/palliative_absolute_by_hospital_results.RData')
  all_diffs_palliative = mutate(all_diffs_palliative, hospital = deidentify_hospital(hospital)) # blind
}
# table
for_table = mutate(all_diffs_palliative, cell = paste(Event, ' (', CI, ')', sep='')) %>%
  select(hospital, Phase, cell) %>%
  pivot_wider(names_from = hospital, values_from = cell) %>%
  select(Phase, X, Y, Z) # in intervention order
#
ftab = flextable(for_table) %>%
  theme_box() %>%
  autofit()
ftab
```


#### Time-to-event model checking (palliative care referral)

##### a) Baseline hazard

Here we plot the baseline hazard in each team. This is useful for checking the differences between hospitals. The plots are limited to the first `r pred_time` days. 

```{r, fig.width=8}
base = basehaz(cox_model_palliative, centered=TRUE) %>%
  tidyr::separate(strata, into=c('hospital','team')) %>%
  mutate(hosp_ordered = factor(hospital, levels=c('X','Y','Z'))) # 
# add team numbers to legend
counts = group_by(base, hospital, team) %>%
  tally() %>%
  mutate(team_number = paste(team, ' (', n, ')', sep=''))
base = left_join(base, counts, by=c('hospital','team'))
#
bplot = ggplot(data=base, aes(x=time, y=hazard, col=team_number)) +
  geom_line() +
  scale_color_hue('Team') +
  #scale_x_continuous(limits=c(0,pred_time)) +
  coord_cartesian(xlim=c(0,pred_time))+ # limit based on censoring
  xlab('Time, days') +
  ylab('Cumulative hazard') +
  facet_wrap(~hosp_ordered) +
  g.theme
bplot
```

There are relatively large differences in hazards between the teams, and some of these differences are within the same hospital. 

##### b) Proportional hazards assumption

Here we check the proportional hazards assumption for the Cox model. A non-proportional hazard would mean that a variable would change over time, e.g., age having a greater effect at longer times. The grey circles are the residuals and the green line is the smoothed residuals. If the hazards are proportional then this line will be flat. The red shaded area is a 95% confidence interval for the smoothed line.

```{r, fig.height=7}
x.times = c(0.01, 0.1, 1, 5, 10, 40) # times for x-axis
resplot = ggplot(data=all_res_cox_palliative, aes(x=log2(time), y=res)) +
  geom_hline(lty=2, yintercept = 0) +
  geom_point(col='grey77', shape=1) +
  scale_x_continuous(breaks=log2(x.times), labels=x.times) +
  geom_smooth(col='darkseagreen4', size=1.05, se=TRUE, method='loess', span=0.8, fill='red') +
  ylab('Schoenfeld residual') +
  xlab('Time from admission, days') +
  theme_bw() +
  facet_grid(var~hospital)
resplot
```

The scales on the y-axis are different. Because of the strong skew in times, we have log-transformed the x-axis.

SPICT score may have a stronger effect earlier in the stay. The effect of CriSTAL may be different for patients who have already spent many days in hospital. 

##### c) Checking for influential patients

Here we check whether there are influential patients in the Cox time-to-event analysis. An influential patient is one who has a large effect of the estimates and hence any inference.

The plot below shows the 'dfbetas' which are the estimated changes in the regression coefficients after deleting each observation patient in turn. 

```{r, fig.height=8, fig.width=9}
#
grid.arrange(influence_cox_palliative[['X']],
 influence_cox_palliative[['Y']],
 influence_cox_palliative[['Z']], ncol=1)
```

The x-axis of observation ID is the order in which patients were recruited over time. 

# Sensitivity analyses

## Sensitivity analyses #1: calendar time scale in the time-to-event analyses

```{r make_times, include=FALSE}
### make the intervention times on a calendar time
# starting date/time (usual care)
ref_datetime = ISOdatetime(year=2020, month=5, day=25, hour=0, min=0, sec=1, tz='Australia/Brisbane')
ref_datetime = as.numeric(ref_datetime)
# intervention times
load('data/date_changes.RData') # from 0_date_changes.R
date_changes = mutate(date_changes, hosp_ordered = factor(hospital, levels=c('X','Y','Z')))
lines = select(date_changes, hospital, hosp_ordered, date_intervention) %>%
  mutate(line = as.POSIXct(date_intervention, tz='Australia/Brisbane'),
         line = as.numeric(line),
         time = (line - ref_datetime)/(60*60*24)) # difference from starting date
# ticks for x-axis
ticks = data.frame(dates = c('2020-06-01','2020-08-01','2020-10-01','2020-12-01','2021-02-01','2021-04-01','2021-06-01')) %>%
  mutate(dates = as.Date(dates),
         ticks = as.numeric(dates),
         ticks = ticks - min(ticks), # day from first date
         labels = format(dates, '%e %b %Y'))

# Smoothing window
window = 30 # window size in days (one-sided, looking forward)
```

Here we use patients' calendar time in the time-to-event analysis in place of patients' time since ward admission. This allows us to look over time to check for: 1) Unusual patterns over time, which could be due to other important events, such as COVID lockdowns, 2) The effect of the intervention, and whether any effect was consistent over calendar time. We did not add the intervention phase as a variable in this analysis because it is confounded with calendar time. 

An initial model using the scrambled data found that stratifying by team within hospital meant some baseline hazards were relatively erratic due to the small number of events in some teams. Hence we instead stratified only on hospital for this analysis. The estimates of baseline hazard therefore show the average results over time across the hospital. Team was added as a variable in the model to control for long-term differences between teams in the rates of outcomes 4, 5 and 6. 

Our initial approach was to use the baseline hazard over time. However we changed this to using a smoothing window approach by re-running the Cox survival model in windows of calendar time. We used a window of `r window` days. This change was because we could more clearly see changes over calendar time in the first quartile time and proportion of patients experience the outcome.

The analysis and plots below *include* the establishment phase, this is because this four week period could provide useful information on trends and excluding cuts a window of time from the middle of the data.


### a) Time to clinician-led care review discussion

#### Plot of first quartile time to outcome by calendar time (clinician-led care review)

```{r, fig.width=8}
# get again from survival data without excluding establishment
for_model_care_review_with_establishment = filter(survival_data,
                  outcome == 'care_review') %>%
  left_join(data_to_add, by='participant_id')
# put data on alternative time scale 
calendar_time_care_review = calendar_time(indata=for_model_care_review_with_establishment, changes=date_changes) # see 99_functions.R

# smooth over calendar time using a window
start_time = 1
end_time = floor(max(calendar_time_care_review$start) - window)
smooth_time_care_review = smooth_prop_care_review = NULL
for (hosp in c('X','Y','Z')){
for (time in start_time:end_time){ # loop through calendar time one day at a time
  start_window = time + 0 # one-way window
  end_window = time + window
  data_window = filter(calendar_time_care_review, 
                hospital == hosp, # by hospital
                start < end_window, # in the time window: must have started ...
                end > start_window) %>% # ... must not have ended 
    mutate(start = start - start_window, # reset clock to the start of the window
           end = end - start_window)
  # use cox model, include prior and yes as events
  fit = coxph(Surv(time = start, time2=end, event = event %in% c('Prior','Yes')) ~ pt_sex + I(age/5) + factor(team), data=data_window) # do not stratify on team, average across hospital; adjust for team as a factor
  q = quantile(survfit(fit), probs=0.25) # 0.25, changed from median time
  frame = data.frame(hospital=hosp, time=time, q1=q$quantile, lower=q$lower, upper=q$upper)
  smooth_time_care_review = bind_rows(smooth_time_care_review, frame)
  # proportion of events
  prop = group_by(data_window, event) %>%
    tally() %>%
    mutate(p = prop.table(n)) %>%
    mutate(hospital=hosp, time=time)
  smooth_prop_care_review = bind_rows(smooth_prop_care_review, prop)
}
}

## plot q1
# add ordered hospitals
smooth_time_care_review = mutate(smooth_time_care_review,
            hosp_ordered = factor(hospital, levels=c('X','Y','Z')))
#
mplot = ggplot(data=smooth_time_care_review, aes(x=time, y=q1, col=hosp_ordered)) +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  geom_line() +
  scale_color_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels)+
  xlab('Calendar time') +
  ylab('First quartile time (days)') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  theme(legend.position='none',
        axis.text.x = element_text(angle = 45, hjust=1))
mplot
```

```{r, include=FALSE}
## calendar plots per team ##
smooth_prop_care_review_teams = NULL
teams = unique(calendar_time_care_review$team)
for (this_team in teams){
for (time in start_time:end_time){ # loop through calendar time one day at a time
  start_window = time + 0 # one-way window
  end_window = time + window
  data_window = filter(calendar_time_care_review, 
                team == this_team, # by team
                start < end_window, # in the time window: must have started ...
                end > start_window) %>% # ... must not have ended 
    mutate(start = start - start_window, # reset clock to the start of the window
           end = end - start_window)
  # proportion of events
  prop = group_by(data_window, event) %>%
    tally() %>%
    mutate(p = prop.table(n)) %>%
    mutate(team = this_team, time = time)
  smooth_prop_care_review_teams = bind_rows(smooth_prop_care_review_teams, prop)
}
}
```


The plot shows the first quartile time by hospital and calendar time, with shorter times indicating a better outcome. The vertical dotted line shows the change-over to the intervention phase. We originally used the median time (2nd quartile) but there were too few events during some times to estimate the median. 

#### Plot of event proportions by calendar time (clinician-led care review)

```{r, fig.width=8}
## plot proportion
# add ordered hospitals
smooth_prop_care_review = mutate(smooth_prop_care_review,
            hosp_ordered = factor(hospital, levels=c('X','Y','Z'))) 
#
pplot = ggplot(data=smooth_prop_care_review, aes(x=time, y=p, fill=event)) +
  geom_bar(stat='identity', position='stack') +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  scale_fill_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels, expand=c(0,0))+
  scale_y_continuous(expand=c(0,0))+
  xlab('Calendar time') +
  ylab('Proportion of outcomes') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  guides(fill=guide_legend(nrow = 1)) + # for legend
  theme(legend.position='top',
        axis.text.x = element_text(angle = 45, hjust=1))
pplot
```

The plot shows the proportion of patients experiencing each outcome by calendar time. The colours indicate the patients' final outcome. So a "Yes" means the patient ultimately experienced the outcome. "Intervention" means the patient changed over to the intervention period before they experienced the event or were discharged. "Post-Intervention" means the study ended before the patient experienced the event or were discharged.

#### Plot of event numbers by calendar time (clinician-led care review)

```{r, fig.width=8}
## plot numbers
nplot = ggplot(data=smooth_prop_care_review, aes(x=time, y=n, fill=event)) +
  geom_bar(stat='identity', position='stack') +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  scale_fill_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels, expand=c(0,0))+
  scale_y_continuous(expand=c(0,0))+
  xlab('Calendar time') +
  ylab('Number of patients') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  guides(fill=guide_legend(nrow = 1)) + # for legend
  theme(legend.position='top',
        axis.text.x = element_text(angle = 45, hjust=1))
nplot
```

### b) Time to care directives documents

#### Plot of first quartile time to event by calendar time (care directives documents)

```{r, fig.width=8}
# get again from survival data without excluding establishment
for_model_care_directive_with_establishment = filter(survival_data_imputed[[1]],
                  outcome == 'care_directive') %>%
  left_join(data_to_add, by='participant_id')

# put data on alternative time scale 
calendar_time_care_directive = calendar_time(for_model_care_directive_with_establishment, changes=date_changes) # see 99_functions.R

# smooth over calendar time using a window
start_time = 1
end_time = floor(max(calendar_time_care_directive$start) - window)
smooth_time_care_directive = smooth_prop_care_directive = NULL
for (hosp in c('X','Y','Z')){
for (time in start_time:end_time){ # loop through calendar time one day at a time
  start_window = time + 0
  end_window = time + window
  data_window = filter(calendar_time_care_directive, 
                hospital == hosp, # by hospital
                start < end_window, # in the time window: must have started ...
                end > start_window) %>% # ... must not have ended 
    mutate(start = start - start_window, # reset clock to the start of the window
           end = end - start_window)
  # use cox model
  fit = coxph(Surv(time = start, time2=end, event = event== 'Yes') ~ pt_sex + I(age/5) + factor(team), data=data_window) # do not stratify on team, average across hospital; adjust for team as a factor
    q = quantile(survfit(fit), probs=0.25) # 0.25, changed from median time
  frame = data.frame(hospital=hosp, time=time, q1=q$quantile, lower=q$lower, upper=q$upper)
  smooth_time_care_directive = bind_rows(smooth_time_care_directive, frame)
  # proportion and number of events
  prop = group_by(data_window, event) %>%
    tally() %>%
    mutate(p = prop.table(n)) %>%
    mutate(hospital=hosp, time=time)
  smooth_prop_care_directive = bind_rows(smooth_prop_care_directive, prop)
}
}

## plot q1
# add ordered hospitals
smooth_time_care_directive = mutate(smooth_time_care_directive,
            hosp_ordered = factor(hospital, levels=c('X','Y','Z')))
#
mplot = ggplot(data=smooth_time_care_directive, aes(x=time, y=q1, col=hosp_ordered)) +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  geom_line() +
  scale_color_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels)+
  xlab('Calendar time') +
  ylab('First quartile time (days)') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  theme(legend.position='none',
        axis.text.x = element_text(angle = 45, hjust=1))
mplot
```

```{r, include=FALSE}
## calendar plots per team ##
smooth_prop_care_directive_teams = NULL
teams = unique(calendar_time_care_directive$team)
for (this_team in teams){
for (time in start_time:end_time){ # loop through calendar time one day at a time
  start_window = time + 0 # one-way window
  end_window = time + window
  data_window = filter(calendar_time_care_directive, 
                team == this_team, # by team
                start < end_window, # in the time window: must have started ...
                end > start_window) %>% # ... must not have ended 
    mutate(start = start - start_window, # reset clock to the start of the window
           end = end - start_window)
  # proportion of events
  prop = group_by(data_window, event) %>%
    tally() %>%
    mutate(p = prop.table(n)) %>%
    mutate(team = this_team, time = time)
  smooth_prop_care_directive_teams = bind_rows(smooth_prop_care_directive_teams, prop)
}
}
```


#### Plot of event proportions by calendar time (care directives documents)

```{r, fig.width=8}
## plot proportion
# add ordered hospitals
smooth_prop_care_directive = mutate(smooth_prop_care_directive,
            hosp_ordered = factor(hospital, levels=c('X','Y','Z'))) 
#
pplot = ggplot(data=smooth_prop_care_directive, aes(x=time, y=p, fill=event)) +
  geom_bar(stat='identity', position='stack') +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  scale_fill_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels, expand=c(0,0))+
  scale_y_continuous(expand=c(0,0))+
  xlab('Calendar time') +
  ylab('Proportion of outcomes') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  guides(fill=guide_legend(nrow = 1)) + # for legend
  theme(legend.position='top',
        axis.text.x = element_text(angle = 45, hjust=1))
pplot
```

#### Plot of event numbers by calendar time (care directives documents)

```{r, fig.width=8}
## plot numbers
nplot = ggplot(data=smooth_prop_care_directive, aes(x=time, y=n, fill=event)) +
  geom_bar(stat='identity', position='stack') +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  scale_fill_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels, expand=c(0,0))+
  scale_y_continuous(expand=c(0,0))+
  xlab('Calendar time') +
  ylab('Number of patients') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  guides(fill=guide_legend(nrow = 1)) + # for legend
  theme(legend.position='top',
        axis.text.x = element_text(angle = 45, hjust=1))
nplot
```

### c) Time to palliative care referral

#### Plot of first quartile time to outcome by calendar time (palliative care referral)

```{r, fig.width=8}
# get again from survival data without excluding establishment
for_model_palliative_with_establishment = filter(survival_data,
                  outcome == 'palliative_care_referral') %>%
  left_join(data_to_add, by='participant_id')

# put data on alternative time scale 
calendar_time_palliative = calendar_time(for_model_palliative_with_establishment, changes=date_changes) # see 99_functions.R

# smooth over calendar time using a window
start_time = 1
end_time = floor(max(calendar_time_care_review$start) - window)
smooth_time_palliative = smooth_prop_palliative = NULL
for (hosp in c('X','Y','Z')){
for (time in start_time:end_time){ # loop through calendar time one day at a time
  start_window = time + 0 
  end_window = time + window
  data_window = filter(calendar_time_palliative, 
                hospital == hosp, # by hospital
                start < end_window, # in the time window: must have started ...
                end > start_window) %>% # ... must not have ended 
    mutate(start = start - start_window, # reset clock to the start of the window
           end = end - start_window)
  # use cox model
  fit = coxph(Surv(time = start, time2=end, event = event== 'Yes') ~ pt_sex + I(age/5) + factor(team), data=data_window) # do not stratify on team, average across hospital; adjust for team as a factor
  q = quantile(survfit(fit), probs=0.25) # 0.25, changed from median time
  frame = data.frame(hospital=hosp, time=time, q1=q$quantile, lower=q$lower, upper=q$upper)
  smooth_time_palliative = bind_rows(smooth_time_palliative, frame)
  # proportion of events
  prop = group_by(data_window, event) %>%
    tally() %>%
    mutate(p = prop.table(n)) %>%
    mutate(hospital=hosp, time=time)
  smooth_prop_palliative = bind_rows(smooth_prop_palliative, prop)
}
}

## plot q1
# add ordered hospitals
smooth_time_palliative = mutate(smooth_time_palliative,
            hosp_ordered = factor(hospital, levels=c('X','Y','Z')))
#
mplot = ggplot(data=smooth_time_palliative, aes(x=time, y=q1, col=hosp_ordered)) +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  geom_line() +
  scale_color_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels)+
  xlab('Calendar time') +
  ylab('First quartile time (days)') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  theme(legend.position='none',
        axis.text.x = element_text(angle = 45, hjust=1))
mplot
```

There are not enough palliative care events to clearly examine time to the first quartile, and this is why there are some gaps in the lines.

```{r, include=FALSE}
## calendar plots per team ##
smooth_prop_palliative_teams = NULL
teams = unique(calendar_time_palliative$team)
for (this_team in teams){
for (time in start_time:end_time){ # loop through calendar time one day at a time
  start_window = time + 0 # one-way window
  end_window = time + window
  data_window = filter(calendar_time_palliative, 
                team == this_team, # by team
                start < end_window, # in the time window: must have started ...
                end > start_window) %>% # ... must not have ended 
    mutate(start = start - start_window, # reset clock to the start of the window
           end = end - start_window)
  # proportion of events
  prop = group_by(data_window, event) %>%
    tally() %>%
    mutate(p = prop.table(n)) %>%
    mutate(team = this_team, time = time)
  smooth_prop_palliative_teams = bind_rows(smooth_prop_palliative_teams, prop)
}
}

```

#### Plot of event proportions by calendar time (palliative care referral)

```{r, fig.width=8}
## plot proportion
# add ordered hospitals
smooth_prop_palliative = mutate(smooth_prop_palliative,
            hosp_ordered = factor(hospital, levels=c('X','Y','Z'))) 
#
pplot = ggplot(data=smooth_prop_palliative, aes(x=time, y=p, fill=event)) +
  geom_bar(stat='identity', position='stack') +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  scale_fill_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels, expand=c(0,0))+
  scale_y_continuous(expand=c(0,0))+
  xlab('Calendar time') +
  ylab('Proportion of outcomes') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  guides(fill=guide_legend(nrow = 1)) + # for legend
  theme(legend.position='top',
        axis.text.x = element_text(angle = 45, hjust=1))
pplot
```

#### Plot of event numbers by calendar time (clinician-led care review)

```{r, fig.width=8}
## plot numbers
nplot = ggplot(data=smooth_prop_palliative, aes(x=time, y=n, fill=event)) +
  geom_bar(stat='identity', position='stack') +
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at change
  scale_fill_manual(NULL, values=cbPalette)+
  scale_x_continuous(breaks=ticks$ticks, labels=ticks$labels, expand=c(0,0))+
  scale_y_continuous(expand=c(0,0))+
  xlab('Calendar time') +
  ylab('Number of patients') +
  g.theme+
  facet_wrap(~hosp_ordered, scales='free_y')+
  guides(fill=guide_legend(nrow = 1)) + # for legend
  theme(legend.position='top',
        axis.text.x = element_text(angle = 45, hjust=1))
nplot
```


## Sensitivity analyses #2: weekend and after-hours effects

Here we include an effect of the weekend and after hours. This is important to rule out any confounding over time due to a change in the times or days when patients presented to hospital (for example, more in-hours patients during the intervention phase). In-hours is defined as an admission date/time of 8am to 4pm Monday to Friday, with all other times as out-of-hours. Using admission time means there is no missing data for the date or time.

We expand the time-to-event data for each patient to cover the times they were in- or out-of-hours. Patients moved between the 'in-hours' and 'out-of-hours' groups during their stay.

### a) clinician-led care review discussion

```{r}
# create long versions of weekend time with changes for in hours vs other hours
# takes a while due to loop
weekend_time_care_review = weekend_time(for_model_care_review) # see 99_functions.R

# run Cox model
cox_model_care_review_in_hours = coxph(Surv(time = start, time2=end, event = event==1) ~  + I(age/5) + pt_sex + in_hours + strata(team), data = weekend_time_care_review)
ests = tidy(cox_model_care_review_in_hours, conf.int = TRUE) %>%
  filter(!is.na(estimate)) %>%
  mutate(
    Variable = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    CI = paste(conf.low, ' to ' , conf.high, sep='')) %>%
  select(Variable, HR, CI)
ft = flextable(ests) %>%
  theme_box() %>%
  autofit()
ft
```

The table shows the hazard ratios and 95% confidence intervals. 
Care reviews are far more likely to occur in-hours. This strong effect is also shown in the previous circular plots.

### b) Completion of care directive documents

```{r}
# create long versions of weekend time with changes for in hours vs other hours
# takes a while due to loop
weekend_time_care_directive = weekend_time(for_model_care_directive[[1]]) # see 99_functions.R

# run Cox model
cox_model_care_directive_in_hours = coxph(Surv(time = start, time2=end, event = event==1) ~ I(age/5) + pt_sex + in_hours + strata(team), data = weekend_time_care_directive)
ests = tidy(cox_model_care_directive_in_hours, conf.int = TRUE) %>%
  filter(!is.na(estimate)) %>%
  mutate(
    Variable = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    CI = paste(conf.low, ' to ' , conf.high, sep='')) %>%
  select(Variable, HR, CI)
ft = flextable(ests) %>%
  theme_box() %>%
  autofit()
ft
```

The table shows the hazard ratios and 95% confidence intervals. 
Care directives are far more likely to occur in-hours.


### c) palliative care referral

```{r}
# create long versions of weekend time with changes for in hours vs other hours
# takes a while due to loop
weekend_time_palliative = weekend_time(for_model_palliative) # see 99_functions.R

# run Cox model
cox_model_palliative_in_hours = coxph(Surv(time = start, time2=end, event = event==1) ~ I(age/5) + pt_sex + in_hours + strata(team), data = weekend_time_palliative)
ests = tidy(cox_model_palliative_in_hours, conf.int = TRUE) %>%
  filter(!is.na(estimate)) %>%
  mutate(
    Variable = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    CI = paste(conf.low, ' to ' , conf.high, sep='')) %>%
  select(Variable, HR, CI)
ft = flextable(ests) %>%
  theme_box() %>%
  autofit()
ft
```

Palliative care referrals are far more likely to occur in-hours and less likely to occur for women.

## Sensitivity analyses #3: Interaction with SPICT and CriSTAL scores

Here we examine if the intervention interacted with the patients' SPICT and CriSTAL scores.
To do this we included the SPICT and CriSTAL scores, and interaction terms between the scores and intervention in the time-to-event models. As SPICT and CriSTAL are likely correlated, we check our models for colinearity.

### a) Clinician-led care review discussion

```{r}
# add variables to data
less_baseline = select(baseline, -hospital, -team, -int_time, -age, -pt_sex, -team, -cristal_score, -spict_score)
for_model_care_review_cph = left_join(for_model_care_review, less_baseline, by="participant_id")

# had to set this, even though I don't use it
dd = datadist(for_model_care_review_cph)
options(datadist="dd")
#
interaction_results = score_interaction(indata = for_model_care_review_cph)
ft = flextable(interaction_results$ests) %>%
  theme_box() %>%
  autofit()
ft
```

The plot below visualises the interactions.

```{r, fig.width=7}
print(interaction_results$plot)
```

The plots are shown for a 75 year old female. 

##### Co-linearity check

```{r}
# added after scrambling
vif = data.frame(vif(interaction_results$model))
names(vif) = 'VIF'
vif$Variable = rownames(vif)
vif = mutate(vif, VIF= roundz(VIF, 1),
             Variable = nice_rename(Variable)) %>%
  select('Variable','VIF')
ftab = flextable(vif) %>%
  theme_box() %>%
  autofit()
ftab
```

We check for co-linearity using the variance inflation factor (VIF). A VIF over 5 would indicate co-linearity concerns.

### b) Completion of care directive documents

```{r}
# add variables
for_model_care_directive_cph = left_join(for_model_care_directive[[1]], less_baseline, by="participant_id")
#
interaction_results = score_interaction(indata = for_model_care_directive_cph)
ft = flextable(interaction_results$ests) %>%
  theme_box() %>%
  autofit()
ft
```

The plot below visualises the interactions.

```{r, fig.width=7}
print(interaction_results$plot)
```

The plots are shown for a 75 year old female. 

##### Co-linearity check

```{r}
# added after scrambling
vif = data.frame(vif(interaction_results$model))
names(vif) = 'VIF'
vif$Variable = rownames(vif)
vif = mutate(vif, VIF= roundz(VIF, 1),
             Variable = nice_rename(Variable)) %>%
  select('Variable','VIF')
ftab = flextable(vif) %>%
  theme_box() %>%
  autofit()
ftab
```

We check for co-linearity using the variance inflation factor (VIF). A VIF over 5 would indicate co-linearity concerns.

### c) Palliative care

```{r}
# add variables
for_model_palliative_cph = left_join(for_model_palliative, less_baseline, by="participant_id")
#
interaction_results = score_interaction(indata = for_model_palliative_cph)
ft = flextable(interaction_results$ests) %>%
  theme_box() %>%
  autofit()
ft
```

The plot below visualises the interactions.

```{r, fig.width=7}
print(interaction_results$plot)
```

The plots are shown for a 75 year old female. 

##### Co-linearity check

```{r}
# added after scrambling
vif = data.frame(vif(interaction_results$model))
names(vif) = 'VIF'
vif$Variable = rownames(vif)
vif = mutate(vif, VIF= roundz(VIF, 1),
             Variable = nice_rename(Variable)) %>%
  select('Variable','VIF')
ftab = flextable(vif) %>%
  theme_box() %>%
  autofit()
ftab
```

We check for co-linearity using the variance inflation factor (VIF). A VIF over 5 would indicate co-linearity concerns.


# Exploratory analysis of time to high-risk

Here we examine the time between the: 1) admission to the recruited clinical team, and 2) first high-risk CriSTAL or SPICT-positive identification. We compare these times for the usual care and intervention phases. The purpose of this analysis is to check whether there was not a speeding (or slowing) of this time as this could confound the effects of the intervention. 

We use the form complete time to determine the time of CriSTAL or SPICT-positive. This analysis is just for those found to be at risk (using either the CRiSTAL or SPICT).

```{r, fig.width=7.5}
# time from admission to median form
explore = select(baseline, hospital, hosp_ordered, participant_id, at_risk, int_time, admission_datetime, median_form) %>%
  filter(at_risk == 'At risk') %>% # just at risk
  mutate(time = (as.numeric(median_form) - as.numeric(admission_datetime))/(60*60*24)) # in days
hplot = ggplot(data=explore, aes(x=int_time, y=time)) +
  geom_boxplot() +
  xlab('') +
  ylab('Time from admission, days') +
  coord_flip() +
  g.theme+
  facet_wrap(~hosp_ordered)
hplot
```

# Time to documentation.

Here we examine the impact of time to documentation of continuing active treatment or family conflict, which could be a strong competing risk for documentation of care review activities. We examine the interplay between these events using data from the usual care phase only.

The table below shows the counts of any documentation of family conflict.
There were few conflicts documented.

```{r}
uc = filter(clinicianled_review, int_time == 'Usual care')
table = mutate(uc, 
              care_review_conflict = as.character(care_review_conflict),
              care_review_conflict = ifelse(is.na(care_review_conflict)==TRUE, 'Missing', care_review_conflict))  %>%
 tabyl(care_review_conflict) %>%
  adorn_totals("row") %>%
  mutate(percent = round(percent*100)) %>%
  rename('Conflict' = 'care_review_conflict')
ftab = flextable(table) %>%
  theme_box() %>%
  autofit()
ftab
```


The table below shows the number of times that active treatment was continued or increased.

```{r}
uc = filter(care_directive_types, int_time == 'Usual care')
table = mutate(uc, 
              Action = ifelse(is.na(Action)==TRUE, 'Missing', Action))  %>%
 tabyl(Action, checked) %>%
  adorn_totals("row") 
ftab = flextable(table) %>%
  theme_box() %>%
  autofit()
ftab
```


## Sensitivity analyses #4: CRiSTAL and SPICT scores over time by hospital

Here we examine average CRiSTAL and SPICT scores over time for at-risk patients. This analysis was added after seeing the original results and the importance of CRiSTAL and SPICT scores on the three outcomes. The aim is to see if there was a general change in case-mix over time.

#### a) CRiSTAL score over time by hospital

```{r, fig.width=8}
for_plot = filter(baseline, 
                   redcap_version == 3,
                   at_risk == "At risk")
# add smooth
gplot = ggplot(data=for_plot, aes(x=admission_date, y=cristal_score))+
#  geom_point(pch=1, col='grey66')+
  geom_vline(data=date_changes, aes(xintercept=date_intervention), lty=2) + # vertical reference line at intervention time
  geom_vline(data=lines, aes(xintercept=time), lty=2) + # vertical reference line at intervention time
  geom_smooth(col='dark red', method = "loess", se=TRUE, span=0.8)+
  xlab('Admission date')+
  ylab('Mean CRiSTAL score')+
#  scale_y_continuous(breaks=seq(0,12,2))+
  facet_wrap(~hosp_ordered)+
  theme_bw()+
  theme(panel.grid.minor = element_blank())
gplot
```

The dotted vertical line is the time of the change to the intervention phase. 

#### b) SPICT score over time by hospital

```{r, fig.width=8}
# add smooth
gplot = ggplot(data=for_plot, aes(x=admission_date, y=spict_score))+
  geom_vline(data=date_changes, aes(xintercept=date_intervention), lty=2) + # vertical reference line at intervention time
  geom_smooth(col='dark blue', method = "loess", se=TRUE, span=0.8)+
  xlab('Admission date')+
  ylab('Mean SPICT score')+
#  scale_y_continuous(breaks=seq(0,12,2))+
  facet_wrap(~hosp_ordered)+
  theme_bw()+
  theme(panel.grid.minor = element_blank())
gplot
```

The dotted vertical line is the time of the change to the intervention phase. 

## Sensitivity analyses #5: unplanned admissions over time by hospital

Here we examine unplanned admissions over time as a proportion of all at-risk patients. We exclude general medical wards. The aim is to see if COVID had an impact on the types of patients over time. 

```{r, fig.width=8}
for_plot = filter(baseline, 
                   redcap_version == 3,
                   at_risk == "At risk") %>% # 
  mutate(unplanned = as.numeric(spict_unplan_hosp=='Yes')) # make into a number for plotting, yes vs no/unknown
# add smooth
gplot = ggplot(data=for_plot, aes(x=admission_date, y=unplanned))+
  geom_vline(data=date_changes, aes(xintercept=date_intervention), lty=2) + # vertical reference line at intervention time
  geom_smooth(col='dark blue', method = "loess", se=TRUE, span=0.8)+
  xlab('Admission date')+
  ylab('Unplanned admission')+
  facet_wrap(~hosp_ordered)+
  theme_bw()+
  theme(panel.grid.minor = element_blank())
gplot
```

The smooth line is applied to a numerical version of unplanned hospital admission that is 1 for "yes" and 0 otherwise. The confidence interval for the smooth is sometimes greater than 1. 

## Sensitivity analyses #6: number of patients over time

Here we examine the number of patients entered into the study over time. The aim is to check whether there was a slowing-down in patients at particular times. The plot shows all patients entered into the database, not just those at risk. 

```{r, fig.width=8}
library(splines)
# make frame of all dates
all_dates = seq(min(baseline$admission_date, na.rm=TRUE), max(baseline$admission_date, na.rm=TRUE), 1)
all_dates = expand.grid(hospital=c('X','Y','Z'), admission_date=all_dates)
# Poisson model
for_model = group_by(baseline, admission_date, hospital) %>%
  tally() %>%
  right_join(all_dates, by=c('hospital','admission_date')) %>%
  mutate(n = ifelse(is.na(n)==TRUE, 0, n))
poisson_model = glm(n ~ ns(admission_date,4):hospital + hospital, data=for_model, family=poisson())
pred = as.data.frame(predict.glm(poisson_model, se.fit=TRUE))
for_model = bind_cols(for_model, pred) %>%
        mutate( z = qnorm(0.975),
                   lower = fit - (z*se.fit),
                   upper = fit + (z*se.fit),
                hosp_ordered = factor(hospital, levels=c('X','Y','Z'))) # to show in intervention order)
# plot
gplot = ggplot(data=for_model, aes(x=admission_date, y=fit, ymin=lower, ymax=upper))+
  geom_vline(data=date_changes, aes(xintercept=date_intervention), lty=2) + # vertical reference line at intervention time
  geom_line(size=1.05, col='darkorange2')+
  geom_ribbon(alpha=0.2)+
  xlab('Admission date')+
  ylab('Daily number of patients')+
  facet_wrap(~hosp_ordered)+
  theme_bw()+
  theme(panel.grid.minor = element_blank())
gplot
```

## Sensitivity analyses #7: Number and percentage of at-risk patients over time

##### Plot of numbers at-risk and not at risk

The bars show the number in every week. The scales on the y-axes vary by hospital.

```{r, fig.width=8}
# get weekly numbers
to_plot = select(baseline, hosp_ordered, at_risk, admission_date) %>%
  mutate(admission_week = as.numeric(format(admission_date, '%Y')) + 
           (as.numeric(format(admission_date, '%U'))/53)) %>%
  group_by(hosp_ordered, admission_week) %>%
  summarise(n=n(), at_risk=sum(at_risk == 'At risk'))
long = mutate(to_plot, not = n - at_risk) %>% # change to long format for bars
  pivot_longer(cols=c('at_risk','not'))
# put line on same scale
lines = mutate(lines, line_week = as.numeric(format(date_intervention, '%Y')) + 
           (as.numeric(format(date_intervention, '%U'))/53))
# breaks for x-axis
library(lubridate)
breaks = labels = NULL
for (time in seq(0,24,2)){
 this_date = as.Date("2019-09-01") + months(time)
 this_date_scale = as.numeric(format(this_date, '%Y')) + 
           (as.numeric(format(this_date, '%U'))/53)
 lab = paste(format(this_date, '%b'), format(this_date, '%Y'))
 breaks = c(breaks, this_date_scale)
 labels = c(labels, lab)
}
# plot
bar_plot = ggplot(data=long, aes(x=admission_week, y=n, fill=name))+
  geom_bar(stat='identity', position='stack')+
  geom_vline(data=lines, aes(xintercept = line_week), lty=2) + # vertical reference line at change
  scale_x_continuous(breaks=breaks, labels=labels)+
  scale_fill_manual(NULL, labels=c('At risk','Not at risk'),  values=c('indianred1','skyblue'))+
  theme_bw()+
  theme(panel.grid.minor = element_blank(),
        legend.position = 'top', 
        axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Calendar time')+
  ylab('Number of patients')+
  facet_wrap(~hosp_ordered, scales='free_y')
bar_plot
```

Every hospital has a large drop during the Christmas week. 

##### Plot of proportion at-risk

```{r, fig.width=8}
to_plot = mutate(to_plot, p = 100*(at_risk / n)) # make the percent
# plot
p_plot = ggplot(data=to_plot, aes(x=admission_week, y=p))+
  geom_point()+
  geom_smooth(col='dark red', lty=2)+
  geom_vline(data=lines, aes(xintercept = line_week), lty=2) + # vertical reference line at change
  scale_x_continuous(breaks=breaks, labels=labels)+
  theme_bw()+
  theme(panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Calendar time')+
  ylab('Percentage of screened patients at risk')+
  facet_wrap(~hosp_ordered, scales='free_y')
p_plot
```

The plot shows the weekly proportion at risk and a smoothed line (dotted red line) with 95% confidence interval (grey area). The scales on the y-axes vary by hospital. 

## Sensitivity analyses #8: proportion of uncensored patients

Censored patients are those whose final outcome or discharge was not observed.

```{r}
cens_table = bind_rows(for_model_care_review,
                      for_model_care_directive[[1]],
                      for_model_palliative) %>%
  select(event, hospital, outcome) %>%
  mutate(censored = event %in% c('Intervention','Post-intervention','Censored')) %>%
  group_by(hospital, outcome, censored) %>%
  tally() %>%
  group_by(hospital, outcome) %>%
  mutate(p = prop.table(n),
         cell = paste(n, ' (', round(100*p), ')', sep='')) %>%
  filter(censored == FALSE) %>%
  select(-censored, -n, -p) %>%
  pivot_wider(names_from = 'hospital', values_from='cell')
ftab = flextable(cens_table) %>%
  theme_box() %>%
  autofit()
ftab
```

The table shows the number of patients and percent uncensored, ideally this would be close to 100%. 

## Sensitivity analyses #9: proportion of at-risk patients from aged care facilities

Here we look at the proportion of at-risk patients coming from an aged care facility. Due to the pandemic, there may have been times when these patients were often not transferred to hospital.

```{r, fig.width=8}
to_plot = filter(baseline, at_risk =='At risk') %>%
  select(hosp_ordered, admission_date, cristal_admit_source) %>%
  mutate(admission_week = as.numeric(format(admission_date, '%Y')) + 
           (as.numeric(format(admission_date, '%U'))/53)) %>%
  group_by(hosp_ordered, admission_week) %>%
  summarise(n=n(), racf = sum(cristal_admit_source == 'Yes'),
            p = 100*(racf / n)) # make the percent
# plot
p_plot = ggplot(data=to_plot, aes(x=admission_week, y=p))+
  geom_point()+
  geom_smooth(col='dark green', lty=2)+
  geom_vline(data=lines, aes(xintercept = line_week), lty=2) + # vertical reference line at change
  scale_x_continuous(breaks=breaks, labels=labels)+
  theme_bw()+
  theme(panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Calendar time')+
  ylab('Percentage from RACF')+
  facet_wrap(~hosp_ordered, scales='free_y')
p_plot
```

The dots show the weekly numbers and the green dotted line is a smoothed estimate of the mean with a 95% confidence interval. 

```{r, include=FALSE}
# saving results
results = bind_rows(all_ests_cox_care_review,
all_ests_cox_care_review_no_prior,
all_ests_cox_care_directive,
all_ests_cox_care_directive_no_prior,
all_ests_cox_palliative,
all_ests_cox_palliative_no_prior, .id='model') %>%
  mutate(
  with_prior = case_when(
    model %in% c(1,3,5) == TRUE ~ 1,
    model %in% c(2,4,6) == TRUE ~ 0
  ),
  with_prior = factor(with_prior, levels=0:1, labels=c('No','Yes')),
  outcome = case_when(
    model %in% c(1,2)== TRUE  ~ 3, # reverse for ordering on ggplot
    model %in% c(3,4)== TRUE ~ 2,
    model %in% c(5,6)== TRUE ~ 1
  ),
  outcome = factor(outcome, levels=1:3, labels=c('Palliative care','Care directive','Care review')))
```

# References

