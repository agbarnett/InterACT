---
title: 'InterACT project: overall statistical analyses for all three hospitals'
author: "Adrian Barnett"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  word_document:
    toc: true
    toc_depth: 2
    reference_docx: rmarkdown-styles-reference.docx
---

```{r setup, include=FALSE}
# using formatting in Word document (see above)
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE, error=FALSE, comment='', dpi=400)
options(width=1000) # Wide pages
options(scipen=999) # avoid scientific presentation
source('99_functions.R')
library(cmprsk) # for cumulative incidence
library(broom) # for regression models
library(dplyr)
library(tidyr)
library(stringr)
library(visdat) # for missing data
library(flextable)
library(summarytools)
# global options for summary tools
st_options(plain.ascii = FALSE,       # Always use this option in Rmd documents
            style = "rmarkdown",        # This too
            round.digits = 0, 
            headings = FALSE, 
            footnote = NA,             # Avoids footnotes which would clutter the results
            subtitle.emphasis = FALSE  # Improves layout with some rmarkdown themes
) 

## get the data
data_to_use = 'real'
file_plus = '' # for figures
if(data_to_use=='real'){load('data/FullData.RData')} # from 0_read_data.R 
if(data_to_use=='dummy'){load('data/DummyData.RData'); file_plus='_dummy'} # dummy data from 0_make_dummy_data.R 
# just use version three
baseline = filter(baseline, redcap_version==3)
complete = filter(complete, redcap_version==3)
care_directive = filter(care_directive, redcap_version==3)
palliative_care_referral = filter(palliative_care_referral, redcap_version==3)
clinicianled_review = filter(clinicianled_review, redcap_version==3)

# graphics things:
library(ggplot2)
library(ggalluvial) # for Sankey diagram
library(ggcorrplot) # for correlation matrix
library(ggupset)  # to plot combination of symptoms
library(survminer) # for survival plots
library(gridExtra)
g.theme = theme_bw() + theme(panel.grid.minor = element_blank())
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#999999", "#CC79A7")

# scramble intervention (turn off when ready)
scramble = FALSE # 
```

# Scrambled intervention group

This document contains the statistical analyses for the InterACT study. The initial document was produced using a scrambled intervention group by randomly assigning participants to intervention or control periods. This allowed us to finalise the statistical analyses plan and ensure that all investigators understood the analyses before the real intervention was used.

```{r scramble, include=FALSE}
# scramble from now on
if(scramble==TRUE){
  min_date = as.numeric(as.POSIXct('2020-05-25 00:00', tz='Australia/Brisbane')) # start of usual care
  max_date = as.numeric(as.POSIXct('2021-06-06 00:00', tz='Australia/Brisbane')) # end of intervention
  set.seed(123456)
  baseline = select(baseline, -'int_time') %>% # remove old time
    mutate(
      median_form = runif(min=min_date, max=max_date, n=nrow(baseline)), # random from earliest start till 400 days plus
    median_form = as.POSIXct(median_form, origin='1970-01-01'))
  baseline = int_time(baseline) # make intervention time, see 99_functions
  # now add to outcomes 
  int_time_data = select(baseline, participant_id, int_time) # data with just intervention time
  clinicianled_review = select(clinicianled_review, -'int_time') %>% # remove old time
    left_join(int_time_data, by='participant_id')
  care_directive = select(care_directive, -'int_time') %>% # remove old time
    left_join(int_time_data, by='participant_id')
  palliative_care_referral = select(palliative_care_referral, -'int_time') %>% # remove old time
    left_join(int_time_data, by='participant_id')
}
```

This report shows the summary statistics and analysis for the InterACT study using the date available on `r format(data_date, '%d-%b%-%Y')`. The code is available on [GitHub](https://github.com/agbarnett/InterACT).

# Missing data

Here we give a graphical summary of the missing data. The grey areas show the missing data. The rows are patients and the columns are variables.

These plots include patients in whom baseline data screening was not complete.

### a) Baseline data

```{r, missing.baseline, fig.width=8}
# remove variables that cannot be missing
for.missing = select(baseline, -participant_id, -hospital, -int_time, -complete_456, -baseline_screening_complete,
                     -ends_with('_team'), # not in all hospitals
                     -'cristal_icu_current', -'cristal_admit_ed', # conditional
                     -redcap_version,
                     -starts_with('time'), -starts_with('start_date_time'), -starts_with('end_date_time')) # do not bother with time variables (Secondary interest)
vis_dat(for.missing)
```

##### For patients with complete baseline screening 

```{r, fig.width=8}
for.missing.complete = 
  filter(baseline, baseline_screening_complete == 'Yes') %>%
  select(-participant_id, -hospital, -int_time, -complete_456, -baseline_screening_complete,
                     -ends_with('_team'), # not in all hospitals
                     -'cristal_icu_current', -'cristal_admit_ed', # conditional
                     -redcap_version,
                     -starts_with('time'), -starts_with('start_date_time'), -starts_with('end_date_time')) # do not bother with time variables (Secondary interest)
vis_dat(for.missing.complete)
```

Some Cristal variables were missing from Version 2 of the REDCap data base, e.g., "Pulse Rate less than 40 or greater than 140 bpm". These explain the two "letter boxes" of grey missing in the above plot.

##### For patients with incomplete baseline screening 

```{r, fig.width=8}
for.missing.incomplete = 
  filter(baseline, baseline_screening_complete == 'No') %>%
  select(-participant_id, -hospital, -int_time, -complete_456, -baseline_screening_complete,
                     -ends_with('_team'), # not in all hospitals
                     -'cristal_icu_current', -'cristal_admit_ed', # conditional
                     -redcap_version,
                     -starts_with('time'), -starts_with('start_date_time'), -starts_with('end_date_time')) # do not bother with time variables (Secondary interest)
vis_dat(for.missing.incomplete)
```

#### Numbers missing for baseline data

```{r, fig.width=8}
mplot = naniar::gg_miss_var(for.missing, show_pct = FALSE) 
mplot + xlab('')
```

### b) Screening completion

```{r, missing.screening, fig.width=7}
for.missing = select(complete, -participant_id, -hospital, # remove variables that cannot be missing
                     -discharge, # not in version 3
                     -redcap_version, # generated
                     -starts_with('start_date_time'), -starts_with('end_date_time'), # not that important
                     -covid19_date) # remove conditional variables
vis_dat(for.missing)
```

### c) Clinician-led review discussion: numbers missing

```{r, fig.width=8}
for.missing = select(clinicianled_review, -participant_id, -hospital, # remove variables that cannot be missing
                     -starts_with('start_date_time'), -starts_with('end_date_time'), # not that important
                     -care_review_type_other) # remove conditional variables
naniar::gg_miss_var(for.missing, show_pct = FALSE)
```

### d) Palliative care referral: numbers missing

```{r, fig.width=8}
for.missing = select(palliative_care_referral, -participant_id, -hospital, # remove variables that cannot be missing
                     -starts_with('start_date_time'), -starts_with('end_date_time') # not that important
                     ) # remove conditional variables
naniar::gg_miss_var(for.missing, show_pct = FALSE)
```

### e) Care directive: numbers missing

```{r, fig.width=8}
for.missing = select(care_directive, -participant_id, -hospital, # remove variables that cannot be missing
                     -starts_with('start_date_time'), -starts_with('end_date_time'), # not that important
                     -tracker, -care_directive_other) # remove conditional variables
naniar::gg_miss_var(for.missing, show_pct = FALSE)
```


## Overall numbers

Here are the overall number of patients per hospital for those screened because they are at risk, meaning SPICT or CRiSTAL positive.

The total number of identified patients, 75 years or older, admitted under participating clinical teams, across all three hospitals was `r format(nrow(baseline), big.mark=',')`. 

### Sankey plot of numbers at the key data collection stages

```{r sankey, fig.width=9, fig.height=7}
numbers = group_by(baseline, hospital, baseline_screening_complete, at_risk) %>%
  summarise(Freq = n())
sankey = ggplot(numbers,
   aes(y = Freq, axis1 = hospital, axis2 = baseline_screening_complete, axis3 = at_risk)) +
  geom_alluvium(aes(fill = hospital), width = 1/12) +
  geom_stratum() +
  geom_text(stat = "stratum", infer.label = TRUE) +
  ylab('Number of patients')+
  scale_x_discrete(limits = c("Screened", "Screening\ncomplete",'At risk'), expand = c(.04, .05))+
  scale_fill_manual('Hospital', values = cbPalette)+
  g.theme+
  theme(text = element_text(size=12))
sankey
```

This plot aims to show the flow of patients by hospital through the key data collection stages.

##### Hospitals, number identified

```{r, results='asis'}
with(baseline, freq(hospital, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

##### Hospitals, all baseline screening completed  

```{r, results='asis'}
with(baseline, ctable(hospital, baseline_screening_complete, dnn=c('Hospital',''), round.digits=0, useNA='no'))
```

##### Hospitals, at risk patients for those with baseline screening complete

```{r, results='asis'}
baseline = filter(baseline, baseline_screening_complete=='Yes')
with(baseline, ctable(hospital, at_risk, dnn=c('Hospital',''), round.digits=0, useNA='no'))
```

From now on, all results are for those with baseline screening completed

The table shows the numbers by hospital that were either Cristal or SPICT positive.
The total column shows the total number of patients with complete screening.

##### GCUH teams, at risk patients

```{r, results='asis'}
with(baseline, ctable(gcuh_team, at_risk, dnn=c('GCUH team',''), round.digits=0, useNA='no'))
```

##### RBWH teams, at risk patients

```{r, results='asis'}
with(baseline, ctable(rbwh_team, at_risk, dnn=c('RBWH team',''), round.digits=0, useNA='no'))
```

##### TPCH teams, at risk patients

```{r, results='asis'}
with(baseline, ctable(tpch_team, at_risk, dnn=c('TPCH team',''), round.digits=0, useNA='no'))
```

### On target to reach sample size?

Here we examine if we are on target to reach the sample size. 
The total target sample size is `r 3*7*50*3`, which is 3 at-risk patients per team per week, with 7 teams per hospital, 50 weeks of data collection, and three hospitals. 

```{r}
# Estimate at risk numbers per hospital per week
numbers = filter(baseline, 
                 at_risk == 'At risk',
                 complete_456 == 'Yes') %>%
  select(hospital, admission_date) %>%
  mutate(week = as.numeric(format(admission_date, '%Y')) + as.numeric(format(admission_date, '%U'))/53) %>%
  group_by(hospital, week) %>%
  summarise(n=n()) %>%
  group_by(hospital) %>%
  arrange(week) %>%
  slice_head(prop=0.95) %>% # remove most recent weeks (data collection is ongoing)
  summarise(median = round(median(n)), q1 = round(quantile(n, 0.25)), q3 = round(quantile(n, 0.75)))
flextable(numbers)
```

The table above gives summary statistics (median and inter-quartile range) on the weekly number of at-risk patients with follow-up data available. 
We discard the two most recent weeks, as data collection is likely ongoing.
The target number is `r 3*7` which is 3 patients per week across 7 teams.
We are above the target in two hospitals and below in RBWH.

# Patients screened 

### Screened date

The purpose of this plot is to show the accumulation of patients with complete baseline screening over time.

```{r, out.width='90%'}
# use earliest form date
for.plot = mutate(baseline, 
                  dummy=1,
                  date_seen = as.Date(format(median_form, '%Y-%m-%d'))) %>% # use earliest form for screening date
  group_by(hospital, date_seen, int_time) %>%
  arrange(hospital, date_seen) %>%
  dplyr::select(hospital, date_seen, int_time, dummy) %>%
  group_by(hospital) %>%
  mutate(cum = cumsum(dummy)) %>%
  ungroup()
cplot = ggplot(data=for.plot, aes(x=date_seen, y=cum, lty=int_time, col=factor(hospital)))+
  geom_step()+
  scale_color_manual('Hospital', values=cbPalette)+
  scale_linetype_manual('Time', values=c(1,2,3))+ # add different sizes?
  xlab('Date screened')+
  ylab("Cumulative numbers")+
  g.theme+
  theme(legend.position = c(0.15, 0.65))
cplot
```


### Admission time

```{r, out.width='90%'}
hplot = ggplot(data=baseline, aes(x=admission_time, fill=factor(hospital)))+
  geom_histogram(alpha=0.7, breaks=seq(0,24,1))+
  scale_fill_manual('Hospital', values=cbPalette)+
  xlab('Time of day')+
  ylab("Count")+
  scale_x_continuous(breaks=seq(0,24,6))+
  g.theme+
  theme(legend.position = c(0.15, 0.75))
#  facet_wrap(~at_risk)
hplot
```

The majority of patients were admitted in the afternoon and early evening.

### Times between admission and at-risk screening

We examine the time between the patients' admission date/time to the current ward and the InterACT screening. We use two date/times for screening:

* The earliest date/time from the four screening forms: demographics, clinical criteria, functional status and comorbidities. This is an estimate of when screening started.
* The date/time the screening completion form was completed. This is an estimate of when screening ended.

##### Histogram

```{r, fig.width=8}
# add screening form completion date
for_merge = select(complete, participant_id, start_date_time_dcharg) # just date
to_table = left_join(baseline, for_merge, by='participant_id') %>%
  mutate(
    diff_start = (as.numeric(median_form) - as.numeric(admission_datetime))/(60*60*24), # in days from earliest date
    diff_end = (as.numeric(start_date_time_dcharg) - as.numeric(admission_datetime))/(60*60*24), # in days from latest date
    admission_datetime = as.POSIXct(as.numeric(admission_datetime), tz='Australia/Brisbane', origin='1970-01-01'),
    start_date_time_dcharg = as.POSIXct(as.numeric(start_date_time_dcharg), tz='Australia/Brisbane', origin='1970-01-01')
         ) %>% 
  select(participant_id, hospital, admission_datetime, start_date_time_dcharg, diff_start, diff_end, at_risk) %>%
  group_by(participant_id, at_risk) %>%
  gather(`diff_start`, `diff_end`, key='difference', value='var') %>%
  ungroup() %>%
  mutate(difference = ifelse(str_detect(string=difference, pattern='start'), 'Start', 'End'))
# (checks)
check = filter(to_table, var>60) %>%
  select(-at_risk, -var)
write.csv(check, file='checks/admission_dates.csv', row.names = FALSE, quote=FALSE)
# plot
hplot = ggplot(data=to_table, aes(x=var, fill=at_risk))+
  geom_histogram()+
  scale_fill_manual(NULL, values=cbPalette)+
  xlab('Difference from admissision to screening complete (days)')+
  ylab('Count')+
  facet_grid(difference~hospital, scales = 'free')+
  scale_x_continuous(limits=c(0, NA)) +  # remove few data errors
  theme_bw()
hplot
```

##### Summary statistics

```{r}
stats = group_by(to_table, at_risk, difference, hospital) %>%
  summarise(n = n(),
            missing = sum(is.na(var)),
            q1 = roundz(quantile(var, prob=0.25, na.rm=TRUE),1),
            median = roundz(median(var, na.rm=TRUE),1),
            q3 = roundz(quantile(var, prob=0.75, na.rm=TRUE),1))
ft = flextable(stats)
autofit(ft)
```

The statistics are the number observed, number missing, median and inter-quartile range.

# Demographics

### Patient age

The plot is split by CriSTAL/SPICT positive.

```{r, out.width='100%', fig.width=7}
p <- ggplot(filter(baseline, !is.na(at_risk)), aes(x=factor(hospital), y=age, fill=factor(hospital))) + 
  scale_fill_manual('Hospital', values=cbPalette)+
  geom_violin(alpha=0.5)+
  geom_boxplot(width=0.1)+
  xlab('Hospital')+
  ylab('Age')+
  g.theme+
  facet_wrap(~at_risk)
p
```

### Patient gender

```{r, results='asis'}
freq(baseline$pt_sex, cumul=FALSE, report.nas = FALSE)
```

# SPICT 

The SPICT score has a range from 0 to 6 and uses the following six variables:

* Unplanned hospital admission
* Perform status
* Care others
* Weight loss
* Persist symptoms
* Care focus

### Correlation matrix of SPICT variables

```{r spict.corr}
# function to make yes/no into number
z_makenum <- function(observed) {
  result = ifelse(observed=='Yes', 1, 0)
  return(result)
}
# estimate correlation matrix
to.corr = select(baseline, spict.vars) %>% # these are just yes/no/unknown
  mutate_all(funs(z = z_makenum(.))) %>%
  select(ends_with('_z')) %>%
  rename_at(vars(ends_with("_z")),funs(str_replace(.,"_z","")))  # remove _z from name
corr <- cor(to.corr, use = 'pairwise')
colnames(corr) = row.names(corr) = nice.rename.spict(colnames(corr)) # rename
# plot
diag(corr) = NA # blank diagonals
ggcorrplot(corr) 
# for text around strongest correlation
max.corr = max(corr[lower.tri(corr, diag=FALSE)])
vars = which(corr==max.corr, arr.ind = T)
```

The plot shows the observed correlation between SPICT variables. Correlations for two variables range from -1 if they are perfectly negatively associated, to 0 if there is no association, to +1 if they are perfectly positively associated.

The strongest positive correlation is `r round(max.corr,2)` between "`r row.names(vars)[1]`" and "`r row.names(vars)[2]`". 

### Tables of SPICT variables in each hospital

```{r, results='asis'}
## big summary table
# create summary stats for table / plot
spict = select(baseline, "participant_id", 'hospital', spict.vars) %>%
  tidyr::gather(key='SPICT', value='Response', -`participant_id`, -`hospital`) %>%
  mutate(SPICT = nice.rename.spict(SPICT)) # neaten variable
with(spict, 
     stby(list(x = SPICT, Y = Response), 
          INDICES = hospital, FUN = ctable, totals=FALSE, round.digits=0, useNA='no', dnn=c('SPICT Variable','')))
```


### SPICT score by hospital

```{r, fig.width=8, results='asis'}
to.bar = group_by(baseline, hospital, spict_score) %>%
  summarise(count = n()) %>%
  mutate(fill = as.factor(spict_score >= thresholds$spict_threshold))
spict.bar = ggplot(data=to.bar, aes(x=spict_score, y=count, fill=fill))+ # colour bars by positive
  xlab('SPICT score')+
  ylab('Count')+
  scale_x_continuous(breaks=0:6)+
  geom_bar(stat='identity')+
  scale_fill_manual(NULL, values=c('skyblue','dark blue'))+
  g.theme+
  theme(legend.position = 'none')+
  facet_wrap(~hospital)
spict.bar
```

The darker blue bars show the SPICT-positive patients.

## SPICT positive by hospital

The threshold for SPICT positive is `r thresholds$spict_threshold` or more.

```{r, results='asis'}
baseline = mutate(baseline, 
                  `SPICT positive` = as.numeric(spict_score >= thresholds$spict_threshold),
                  `SPICT positive` = factor(`SPICT positive`, levels=0:1, labels=c('No','Yes')))
with(baseline, ctable(y = `SPICT positive`, x = hospital, round.digits=0, useNA='no', dnn=c('Hospital','')))
```

## Common combinations for SPICT

Here we show the most common combinations of symptoms for patients.

```{r, fig.width=7}
# get combinations of yes responses
yes_responses <-  dplyr::select(baseline, participant_id, spict.vars)  %>%
  as_tibble() %>%
  tidyr::gather(key='spict', value='response', -participant_id) %>%
  filter(response=='Yes') %>% # just yes
  select(-response) %>%
  mutate(spict = nice.rename.spict(spict)  )
# now make list from group responses
list_resp = group_by(yes_responses, participant_id) %>%
  summarise(spicts = list(spict))
# add zeros
all_ids = unique(baseline$participant_id)
missing.ids = all_ids[all_ids %in% list_resp$participant_id == FALSE]
zeros = as_tibble(data.frame(participant_id=missing.ids))
list_resp = bind_rows(list_resp, zeros)
# plot
cplot = ggplot(list_resp, aes(x = spicts)) +
    geom_bar(aes(y=..count../sum(..count..)), fill = "indianred3") +
    g.theme+
    xlab("SPICT variables") +
    ylab("Proportion of patients") +
    scale_x_upset(n_intersections = 20, n_sets = 20) # top twenty
cplot
# export to figure
filename = paste('figures/spict_upset', file_plus, '.jpg', sep='')
jpeg(filename, width=5.5, height=4, quality = 100, res=500, units='in')
print(cplot)
invisible(dev.off())
```

# CriSTAL 

The CriSTAL score has a range from 0 to 18 and uses the following 16 variables:

* Admitted via ED
* Admitted From nursing home
* Age over 75
* Previous hospitalisation in last 12 months
* ICU admission
* Clinical frailty score (thresholds at 5+ and 7+)
* Advanced cancer
* Proteinuria
* Chronic kidney disease
* Abnormal ECG
* Acute myocardial infarction
* Chronic heart failure
* COPD
* Stroke
* Cognitive impairment
* Liver disease

We use two thresholds for the clinical frailty score at 5 or more and 7 or more.

### Correlation matrix of CriSTAL variables

```{r cristal.corr, fig.width=7, fig.height=7}
# function to make yes/no into number
z_makenum <- function(observed) {
  result = ifelse(observed=='Yes', 1, 0)
  return(result)
}
# estimate correlation matrix
to.corr = select(baseline, cristal.vars) %>%
  mutate_at(vars(!ends_with("_cfs_score")), funs(z = z_makenum(.))) %>% # only mutate binary variables
  select(ends_with('_z'), 'cristal_cfs_score') %>%
  rename_at(vars(ends_with("_z")), funs(str_replace(.,"_z",""))) # remove _z from name
corr <- cor(to.corr, use = 'pairwise')
colnames(corr) = row.names(corr) = nice.rename.cristal(colnames(corr)) # rename
colnames(corr)[colnames(corr) == "Frailty score >= 6"] = 'Frailty score'
row.names(corr)[row.names(corr) == "Frailty score >= 6"] = 'Frailty score'
# plot
diag(corr) = NA # blank diagonals
ggcorrplot(corr, tl.cex=8) # cex to reduce text size
# for text around strongest correlation
max.corr = max(corr[lower.tri(corr, diag=FALSE)])
vars = which(corr==max.corr, arr.ind = T)
```

The plot shows the observed correlation between CRiSTAL variables. The strongest positive correlation is `r round(max.corr,2)` between "`r row.names(vars)[1]`" and "`r row.names(vars)[2]`". 

The clinical frailty score is continuous, whereas the other variables are binary. To make the binary variables numeric, we group 'no' and 'unknown' together as zero, and compare them with 'yes' as one.

### Tables of CriSTAL variables in each hospital

```{r, results='asis'}
## big summary table
# create summary stats for table / plot
cristal = select(baseline, "participant_id", 'hospital', cristal.vars) %>%
  mutate(
    #age = ifelse(age>=75, 'Yes', 'No'), # convert to binary , no longer using age in cristal
         cristal_cfs_score1 = ifelse(cristal_cfs_score >= thresholds$frailty_threshold, 'Yes', 'No'), # frailty score over 5,
         cristal_cfs_score2 = ifelse(cristal_cfs_score >= thresholds$frailty_threshold2, 'Yes', 'No') # frailty score over 7,
         ) %>% 
  select(-cristal_cfs_score) %>% # no longer need score
  mutate_if(is.factor, as.character) %>% # convert all yes/no factors to characters
  tidyr::gather(key='CRISTAL', value='Response', -`participant_id`, -`hospital`) %>%
  mutate(CRISTAL = nice.rename.cristal(CRISTAL)) # neaten variable
# 
with(cristal, 
     stby(list(x = CRISTAL, y = Response), 
          INDICES = hospital, FUN = ctable,  totals=FALSE, round.digits=0, useNA='no', dnn=c('CriSTAL Variable',''))) # no totals, get a bit confusing because of multiple variables
```

### CriSTAL score by hospital

```{r, fig.width=8}
to.bar = group_by(baseline, hospital, cristal_score) %>%
  summarise(count = n()) %>%
  mutate(fill = as.factor(cristal_score >= thresholds$cristal_threshold))
cristal.bar = ggplot(data=to.bar, aes(x=cristal_score, y=count, fill=fill))+ # colour bars by positive
  xlab('CriSTAL score')+
  ylab('Count')+
  scale_x_continuous(breaks=0:10)+
#  scale_y_continuous()
  geom_bar(stat='identity')+
  scale_fill_manual(NULL, values=c('skyblue','dark blue'))+
  g.theme+
  theme(legend.position = 'none')+
  facet_wrap(~hospital)
cristal.bar
```

The darker blue bars show the CriSTAL-positive patients.

### CriSTAL score summary statistics by hospital

```{r, cristal.summary, results='asis'}
# would like to fix digits to that N, min, etc are integers, can't use a vector of digits
stby(data = baseline$cristal_score, 
           INDICES = baseline$hospital, 
           FUN = descr, stats = c('N.valid','mean','sd','min','med','max'), transpose = TRUE, round.digits =1)
```

### CriSTAL positive by hospital

```{r, results='asis'}
baseline = mutate(baseline, 
                  `CriSTAL positive` = as.numeric(cristal_score >= thresholds$cristal_threshold),
                  `CriSTAL positive` = factor(`CriSTAL positive`, levels=0:1, labels=c('No','Yes')))
with(baseline, ctable(y = `CriSTAL positive`, x = hospital, round.digits=0, useNA='no', dnn =c('Hospital','')))
```

A CriSTAL positive score is `r thresholds$cristal_threshold` or above, and we apply this for the entire cohort.

## Common combinations for CriSTAL 

Here we show the twenty most common combinations of sign and symptoms for screened patients. 
We do not show age over 75 in this plot, because everyone in our sample is over this age.
If a CriSTAL variable is not shown, it means it was not used in any of the top twenty combinations.

```{r, fig.width=8}
# get combinations of yes responses
yes_responses <-  dplyr::select(baseline, participant_id, cristal.vars)  %>%
  mutate(
    #age = ifelse(age>=75, 'Yes', 'No'), # convert to binary - no longer using age in cristal
         cristal_cfs_score1 = ifelse(cristal_cfs_score >= thresholds$frailty_threshold, 'Yes', 'No'), # frailty score over 5
         cristal_cfs_score2 = ifelse(cristal_cfs_score >= thresholds$frailty_threshold2, 'Yes', 'No')) %>%  # frailty score over 7
  select(-cristal_cfs_score) %>% # no longer needed
  mutate_if(is.factor, as.character) %>% # convert all yes/no factors to characters
  as_tibble() %>%
  tidyr::gather(key='cristal', value='response', -participant_id) %>%
  filter(response=='Yes') %>% # just yes
  select(-response) %>%
  mutate(cristal = nice.rename.cristal(cristal)  )
# now make list from group responses
list_resp = group_by(yes_responses, participant_id) %>%
  summarise(cristals = list(cristal))
# add zeros
all_ids = unique(baseline$participant_id)
missing.ids = all_ids[all_ids %in% list_resp$participant_id == FALSE]
zeros = as_tibble(data.frame(participant_id=missing.ids))
list_resp = bind_rows(list_resp, zeros)
# plot
# to do, colour bar by threshold?
cplot = ggplot(list_resp, aes(x = cristals)) +
    geom_bar(aes(y=..count../sum(..count..)), fill = "#6855CD") +
    g.theme+
    xlab("CriSTAL variables") +
    ylab("Proportion of patients") +
    scale_x_upset(n_intersections = 20, n_sets = 20) # top twenty
cplot
# export to figure
filename = paste('figures/cristal_upset', file_plus, '.jpg', sep='')
jpeg(filename, width=5.5, height=4, quality = 100, res=500, units='in')
print(cplot)
invisible(dev.off())
```

# Clinical frailty score 

Distribution of clinical frailty score by hospital.

```{r, out.width='70%'}
p <- ggplot(baseline, aes(x=factor(hospital), y=cristal_cfs_score, fill=factor(hospital))) + 
  scale_fill_manual('Hospital', values=cbPalette)+
  geom_violin(alpha=0.5, bw=0.8)+ # increase band width to avoid bumps
  geom_boxplot(width=0.1)+
  xlab('Hospital')+
  ylab('Clinical frailty score')+
  scale_y_continuous(breaks=1:9)+
  g.theme
p
```



### Summary of unknowns

Here we look at the number of unknowns as this is useful for identifying variables that are difficult for the auditors to complete. The table below shows the variables with the most amount of unknowns.

```{r}
to_table = select(baseline, participant_id, spict.vars, cristal.vars) %>%
  select(-cristal_cfs_score) %>% # remove scores
  tidyr::gather(key='variable', value='answer', -participant_id) %>% # to long
  filter(answer=='Unknown') %>%
  group_by(variable) %>%
  summarise(Count = n()) %>%
  arrange(-Count) %>%
  mutate(v1 = nice.rename.cristal(variable),
         v2 = nice.rename.spict(variable),
         Variable = ifelse(is.na(v1), v2, v1)) %>%
  select(Variable, Count) %>%
  slice(1:10)
ft = flextable(to_table)
autofit(ft)
```

# Documented care directive prior to this hospital admission

### Numbers with a documented care directive prior to this hospital admission 

For example: Advance Care Plan, Statement of Choices

```{r, results='asis'}
with(baseline, freq(presence_eol_plan, cumul=FALSE, report.nas = FALSE))
```


# Outcome: Clinician-led review discussion

The results in this section only use the first clinician-led review per patient, or for patients without a review the most recently completed form.

### Has a clinician-led care review discussion occurred?

```{r, results='asis'}
# `change_var` is previously `care_review`; renamed because of function
with(clinicianled_review, freq(change_var, round.digits=0, cumul = FALSE, report.nas =FALSE))
```


### Days and times when clinical-led reviews took place

```{r, fig.width=8}
to_plot = circular_plots(clinicianled_review)
grid.arrange(to_plot$week, to_plot$hour, ncol=2)
```

There are `r to_plot$missing_hour` result that are missing the time the referral took place.

### Type of clinician-led review activity

```{r, results='asis'}
# only one box can be ticked
with(clinicianled_review, freq(care_review_type, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

### Difference between screening date and date of clinician-led review

#### Table of difference (days)

```{r, results='asis'}
# note, convert time to negative
with(clinicianled_review, descr(time_change, stats=c('N.Valid','min','Q1','med','Q3','max'), round.digits=0, cumul = FALSE, report.nas =FALSE))
```

#### Histogram of difference

```{r}
hplot = ggplot(data=clinicianled_review, aes(x=time_change))+
  geom_histogram(fill = "#CDAD00")+
  xlab('Days between screening and clinician-led review')+
  g.theme
hplot
```

### Was there any documentation of family conflict?

```{r, results='asis'}
with(clinicianled_review, freq(care_review_conflict, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

# Outcome: Care directive measure

The results in this section only use the first care directive per patient, or for patients without a review the most recently completed form.

### Has there been a review of any care directives?

```{r, results='asis'}
# `change_var` is previously `change_5`; renamed because of function
with(care_directive, freq(change_var, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

### What care review outcomes occurred?

There were eight outcomes and multiple outcomes could be ticked.

##### Upset plot of outcome combinations

The plot below shows the top ten combinations.

```{r, fig.width=7}
# get combinations of yes responses
yes_responses <- filter(care_directive, change_var=='Yes') %>% # only where there's some care directive
  dplyr::select(participant_id, starts_with('type_care_directive'))  %>%
  as_tibble() %>%
  tidyr::gather(key='outcome', value='response', -participant_id) %>%
  filter(response=='Checked') %>% # just yes
  select(-response) %>%
  mutate(outcome = nice.rename.directive(outcome)  )
# now make list from group responses
list_resp = group_by(yes_responses, participant_id) %>%
  summarise(outcomes = list(outcome))
# add zeros
all_ids = filter(care_directive, change_var=='Yes')$participant_id
missing.ids = all_ids[all_ids %in% list_resp$participant_id == FALSE]
zeros = as_tibble(data.frame(participant_id=missing.ids))
list_resp = bind_rows(list_resp, zeros)
# plot
cplot = ggplot(list_resp, aes(x = outcomes)) +
    geom_bar(aes(y=..count..), fill = "pink") +
    g.theme+
    xlab("") +
    ylab("Number of patients") +
    scale_x_upset(n_intersections = 10, n_sets = 10) # top ten
cplot
```

##### Frequency table of outcomes

```{r, results='asis'}
to.table = filter(care_directive, change_var =='Yes') %>%
  select(participant_id, starts_with('type_care_')) %>%
  tidyr::gather(key='num', value='checked', -participant_id) %>%
  mutate(nicevar = nice.rename.directive(num),
         num = as.numeric(str_remove_all(num, '[^0-9]')),
         numf = factor(num, levels=1:8, labels=care_directives), 
         checked = factor(checked, levels=c('Checked','Unchecked'), labels=c('Yes','No')))
with(to.table, ctable(nicevar, checked, dnn=c(' ',''), round.digits=0, totals=FALSE, useNA='no'))
```

##### Bar plot

```{r, fig.width=8}
stack = ggplot(data=to.table, aes(x=numf, fill=checked))+
  geom_bar(position='stack')+
  g.theme+
  scale_x_discrete(limits = rev(levels(to.table$numf)))+ # reverse order to match above table
  scale_fill_manual(NULL, values=c("#00BFFF", "#4EEE94", "#FFFFFF"))+
  coord_flip()+
  xlab('')+
  ylab('Count')
stack
```

### Survival analysis of time to first care directive measure

Here we use survival analysis to examine the time to the first care directive measure. We exclude the establishment phase and so compare the usual care and intervention periods. The plot below shows the cumulative incidence for the first care directive measure by intervention period.

###### Cumulative risks plots (first 40 days)

```{r}
## set up data, multiple exclusions (these are already defined as high-risk patients)


# to do: competing risk for in-hospital death, waiting on routinely collected data as death is not in REDCAp

# exclude prior:
for_model1 = filter(clinicianled_review, 
                   change_var !='Prior')
n_excluded_prior = nrow(clinicianled_review) - nrow(for_model1)
# exclude establishment phase:
for_model2 = filter(for_model1, 
                   int_time != 'Establishment')
n_excluded_establishment = nrow(for_model1) - nrow(for_model2)
# exclude negative times:
for_model3 = filter(for_model2, 
                   time_change >=0) %>%
    mutate(int_time_n = as.numeric(int_time)) # needs to be a number for survminer
n_excluded_negative = nrow(for_model2) - nrow(for_model3) 
# cumulative incidence plot
cum_inc = with(for_model3, cuminc(ftime=time_change, fstatus=change_var=='Yes', group=int_time_n, strata=hospital, cencode='Censored'))
g = ggcompetingrisks(cum_inc,
                 xlab = 'Days',
                 ylab = 'Cumulative probability',
                 xlim = c(0,40), # first 40 days
                 multiple_panels = FALSE,
                 title = '',
#                 gsep = '_', # dummy to prevent groups being created from spaces
                 cumcensor = TRUE, # does not work
                 legend.title='',
                 risk.table = TRUE, # does not work
                 conf_int = TRUE) # does not work
g = g + geom_line(size = 1.05) + # make lines thicker
  theme(legend.position = 'none') # remove legend
g
```

There were `r n_excluded_prior` patients excluded because they already had a valid review prior to this admission. `r n_excluded_establishment` patients were excluded as they were in the establishment period. `r n_excluded_negative` were excluded because their times were negative.

The number of patients censored was `r 1` (to do).

###### Survival model

```{r}
# Cox model stratified on team
# in-hospital death as competing risk
# to here, need to finalise regression model

# add variables from baseline data
data_to_add = select(baseline, participant_id, pt_sex, age, team)
for_model3 = left_join(for_model3, data_to_add, by='participant_id')
# model - do not use Cox, protocol says otherwise
# stratify on hospital
cox_model = coxph(Surv(time = time_change, event = change_var=='Yes') ~ int_time + I(age/5) + pt_sex + strata(team), data = for_model3)
ests = tidy(cox_model, conf.int = TRUE) %>%
  filter(!is.na(estimate)) %>%
  mutate(
    term = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    CI = paste(conf.low, ' to ' , conf.high)) %>%
  select(term, HR, CI)
ft = flextable(ests)
autofit(ft)
```

We used a Cox proportional hazards model stratified on team.
The table shows the hazard ratios and 95% confidence intervals.

###### Survival model checking

Here we plot the baseline hazard in each team.

```{r}
base = basehaz(cox_model, centered=TRUE) %>%
  tidyr::separate(strata, into=c('hospital','team'))
bplot = ggplot(data=base, aes(x=time, y=hazard, col=team))+
  geom_line()+
  scale_x_continuous(limits=c(0,40))+
  xlab('Time, days')+
  facet_wrap(~hospital)+
  g.theme
bplot
```



### Days and times when reviews took place

```{r, fig.width=8}
to_plot = circular_plots(care_directive)
grid.arrange(to_plot$week, to_plot$hour, ncol=2)
```

There are `r to_plot$missing_hour` result that are missing the time the review took place.

### Difference in days between screening date and initiation of care directive measure

#### Table of difference

```{r, results='asis'}
# note, convert time to negative
with(care_directive, descr(time_change, stats=c('N.Valid','min','Q1','med','Q3','max'), round.digits=0, cumul = FALSE, report.nas =FALSE))
```

#### Histogram of difference

```{r}
hplot = ggplot(data=care_directive, aes(x=time_change))+
  geom_histogram(fill = "turquoise4")+
  xlab('Days between screening and initiation of care directive measure')+
  g.theme
hplot
```


### Have the completed document/s been uploaded to 'tracker'?

```{r, results='asis'}
to.table = filter(care_directive, change_var =='Yes')
with(to.table, freq(tracker, round.digits=0, cumul = FALSE, report.nas =FALSE))
```


# Outcome: Palliative care referral

The results in this section only use the first palliative care referral per patient, or for patients without a review the most recently completed form.

### Has this patient been referred to palliative care?

```{r, results='asis'}
# change_var is pall_care
with(palliative_care_referral, freq(change_var, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

### Days and times when referral took place

```{r, fig.width=8}
to_plot = circular_plots(palliative_care_referral)
grid.arrange(to_plot$week, to_plot$hour, ncol=2)
```

There are `r to_plot$missing_hour` result that are missing the time the referral took place.

### Difference in days between screening date and initiation of care directive measure

#### Table of difference

```{r, results='asis'}
# note, convert time to negative
with(palliative_care_referral, descr(time_change, stats=c('N.Valid','min','Q1','med','Q3','max'), round.digits=0, cumul = FALSE, report.nas =FALSE))
```

#### Histograms of differences by hospital

```{r, fig.width=8, fig.height=5}
# TO DO: add treatment as a colour when it becomes available
hplot = ggplot(data=palliative_care_referral, aes(x=time_change))+
  geom_histogram(fill = "darkorange1")+
  xlab('Days between at risk time and initiation of care directive measure (days)')+
  g.theme+
  facet_wrap(~hospital, scales = 'free')
hplot
```

# Appendices

### Appendix A: Times to complete REDCap study forms (in minutes)

```{r, results='asis'}
# arrange time data for group summary
# to do, add N
long = bind_rows(baseline, care_directive, palliative_care_referral, clinicianled_review, complete) %>% # combine all forms with start/end times
  select(participant_id, starts_with('time')) %>%
  tidyr::gather(key='form', value='minutes', -`participant_id`) %>%
  select(-`participant_id`) %>% # avoid this being summarised
  mutate(form = case_when(form=='time_dem' ~ 'Patient demographics',
                          form=='time_hosp' ~ 'Hospital admissions',
                          form=='time_funct' ~ 'Functional status',
                          form=='time_comorb' ~ 'Comorbidities',
                          form=='time_4' ~ 'Clinician-led review discussion',
                          form=='time_5' ~ 'Care directive measure',
                          form=='time_6' ~ 'Palliative care referral',
                          form=='time_dcharg' ~ 'Screening completion'))
#
stby(data = long, 
           INDICES = long$form, 
           FUN = descr, stats = "fivenum", transpose = TRUE)
```

The results above show there are some data entry errors in the date/times for hospital admissions.

<!--- ##c("#FFFFFF", "#FFFFFF", "#FFFFFF") Appendix B: R version info , add at later date --->
<!--- The list below shows the version of the R software and all the packages. This is only needed for technical queries. It also helps with computational reproducibility.--->


