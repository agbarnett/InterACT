---
title: 'InterACT project: overall statistical analyses for all three hospitals'
author: "Adrian Barnett"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  word_document:
    toc: true
    toc_depth: 2
    reference_docx: rmarkdown-styles-reference.docx
---

```{r setup, include=FALSE}
# using formatting in Word document (see above)
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE, error=FALSE, comment='', dpi=400)
options(width=1000) # Wide pages
options(scipen=999) # avoid scientific presentation
source('99_functions.R')
library(cmprsk) # for cumulative incidence
library(broom) # for regression models
library(dplyr)
library(tidyr)
library(stringr)
library(visdat) # for missing data
library(flextable)
library(summarytools)
# global options for summary tools
st_options(plain.ascii = FALSE,       # Always use this option in Rmd documents
            style = "rmarkdown",        # This too
            round.digits = 0, 
            headings = FALSE, 
            footnote = NA,             # Avoids footnotes which would clutter the results
            subtitle.emphasis = FALSE  # Improves layout with some rmarkdown themes
) 

## get the data
data_to_use = 'real'
file_plus = '' # for figures
if(data_to_use=='real'){load('data/FullData.RData')} # from 0_read_data.R 
if(data_to_use=='dummy'){load('data/DummyData.RData'); file_plus='_dummy'} # dummy data from 0_make_dummy_data.R 
# just use version three
baseline = filter(baseline, redcap_version==3)
complete = filter(complete, redcap_version==3)
care_directive = filter(care_directive, redcap_version==3)
palliative_care_referral = filter(palliative_care_referral, redcap_version==3)
clinicianled_review = filter(clinicianled_review, redcap_version==3)

# graphics things:
library(ggplot2)
library(ggalluvial) # for Sankey diagram
library(ggcorrplot) # for correlation matrix
library(ggupset)  # to plot combination of symptoms
library(survminer) # for survival plots
library(gridExtra)
g.theme = theme_bw() + theme(panel.grid.minor = element_blank())
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#999999", "#CC79A7")

# scramble intervention (turn off when ready)
scramble = FALSE # 
```

# Scrambled intervention group

This document contains the statistical analyses for the InterACT study. The initial document was produced using a scrambled intervention group by randomly assigning participants to intervention or control periods. This allowed us to finalise the statistical analyses plan and ensure that all investigators understood the analyses before the real intervention was used.

The scrambling is introduced after we have presented the baseline data.

This report shows the summary statistics and analysis for the InterACT study using the date available on `r format(data_date, '%d-%b%-%Y')`. The code is available on [GitHub](https://github.com/agbarnett/InterACT).

# Missing data

Here we give a graphical summary of the missing data. The grey areas show the missing data. The rows are patients and the columns are variables.

These plots include patients in whom baseline data screening was not complete.

### a) Baseline data

```{r, missing.baseline, fig.width=8}
# remove variables that cannot be missing
for.missing = select(baseline, -participant_id, -hospital, -urn, -int_time, -complete_456, -baseline_screening_complete,
                     -ends_with('_team'), # not in all hospitals
                     -'cristal_icu_current', -'cristal_admit_ed', # conditional
                     -redcap_version,
                     -starts_with('time'), -starts_with('start_date_time'), -starts_with('end_date_time')) # do not bother with time variables (Secondary interest)
vis_dat(for.missing)
```

##### For patients with complete baseline screening 

```{r, fig.width=8}
for.missing.complete = 
  filter(baseline, baseline_screening_complete == 'Yes') %>%
  select(-participant_id, -hospital, -int_time, -complete_456, -baseline_screening_complete,
                     -ends_with('_team'), # not in all hospitals
                     -'cristal_icu_current', -'cristal_admit_ed', # conditional
                     -redcap_version,
                     -starts_with('time'), -starts_with('start_date_time'), -starts_with('end_date_time')) # do not bother with time variables (Secondary interest)
vis_dat(for.missing.complete)
```

Some Cristal variables were missing from Version 2 of the REDCap data base, e.g., "Pulse Rate less than 40 or greater than 140 bpm". These explain the two "letter boxes" of grey missing in the above plot.

##### For patients with incomplete baseline screening 

```{r, fig.width=8}
for.missing.incomplete = 
  filter(baseline, baseline_screening_complete == 'No') %>%
  select(-participant_id, -hospital, -int_time, -complete_456, -baseline_screening_complete,
                     -ends_with('_team'), # not in all hospitals
                     -'cristal_icu_current', -'cristal_admit_ed', # conditional
                     -redcap_version,
                     -starts_with('time'), -starts_with('start_date_time'), -starts_with('end_date_time')) # do not bother with time variables (Secondary interest)
vis_dat(for.missing.incomplete)
```

#### Numbers missing for baseline data

```{r, fig.width=8}
mplot = naniar::gg_miss_var(for.missing, show_pct = FALSE) 
mplot + xlab('')
```

### b) Screening completion

```{r, missing.screening, fig.width=7}
for.missing = select(complete, -participant_id, -hospital, # remove variables that cannot be missing
                     -discharge, # not in version 3
                     -redcap_version, # generated
                     -starts_with('start_date_time'), -starts_with('end_date_time'), # not that important
                     -covid19_date) # remove conditional variables
vis_dat(for.missing)
```

### c) Clinician-led review discussion: numbers missing

```{r, fig.width=8}
for.missing = select(clinicianled_review, -participant_id, -hospital, # remove variables that cannot be missing
                     -starts_with('start_date_time'), -starts_with('end_date_time'), # not that important
                     -redcap_version,
                     -care_review_type_other) # remove conditional variables
naniar::gg_miss_var(for.missing, show_pct = FALSE)
```

### d) Palliative care referral: numbers missing

```{r, fig.width=8}
for.missing = select(palliative_care_referral, -participant_id, -hospital, # remove variables that cannot be missing
                     -redcap_version,
                     -starts_with('start_date_time'), -starts_with('end_date_time') # not that important
                     ) # remove conditional variables
naniar::gg_miss_var(for.missing, show_pct = FALSE)
```

### e) Care directive: numbers missing

```{r, fig.width=8}
for.missing = select(care_directive, -participant_id, -hospital, # remove variables that cannot be missing
                     -starts_with('start_date_time'), -starts_with('end_date_time'), # not that important
                     -tracker, -care_directive_other) # remove conditional variables
naniar::gg_miss_var(for.missing, show_pct = FALSE)
```


## Overall numbers

Here are the overall number of patients per hospital for those screened because they are at risk, meaning SPICT or CRiSTAL positive. The SPICT and CriSTAL full definitions are available online [here](https://tinyurl.com/y2w54mqd). 

The total number of identified patients, 75 years or older, admitted under participating clinical teams, across all three hospitals was `r format(nrow(baseline), big.mark=',')`. 

### Sankey plot of numbers at the key data collection stages

```{r sankey, fig.width=9, fig.height=7}
numbers = group_by(baseline, hospital, baseline_screening_complete, at_risk) %>%
  summarise(Freq = n())
sankey = ggplot(numbers,
   aes(y = Freq, axis1 = hospital, axis2 = baseline_screening_complete, axis3 = at_risk)) +
  geom_alluvium(aes(fill = hospital), width = 1/12) +
  geom_stratum() +
  geom_text(stat = "stratum", infer.label = TRUE) +
  ylab('Number of patients')+
  scale_x_discrete(limits = c("Screened", "Screening\ncomplete",'At risk'), expand = c(.04, .05))+
  scale_fill_manual('Hospital', values = cbPalette)+
  g.theme+
  theme(text = element_text(size=13))
sankey
```

This plot aims to show the flow of patients by hospital through the key data collection stages.

##### Hospitals, number identified

```{r, results='asis'}
with(baseline, freq(hospital, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

##### Hospitals, all baseline screening completed  

```{r, results='asis'}
with(baseline, ctable(hospital, baseline_screening_complete, dnn=c('Hospital',''), round.digits=0, useNA='no'))
```

##### Hospitals, at risk patients for those with baseline screening complete

```{r, results='asis'}
baseline = filter(baseline, baseline_screening_complete=='Yes')
with(baseline, ctable(hospital, at_risk, dnn=c('Hospital',''), round.digits=0, useNA='no'))
```

From now on, all results are for those with baseline screening completed

The table shows the numbers by hospital that were either CriSTAL or SPICT positive.
The total column shows the total number of patients with complete screening.

##### GCUH teams, at risk patients

```{r, results='asis'}
with(baseline, ctable(gcuh_team, at_risk, dnn=c('GCUH team',''), round.digits=0, useNA='no'))
```

##### RBWH teams, at risk patients

```{r, results='asis'}
with(baseline, ctable(rbwh_team, at_risk, dnn=c('RBWH team',''), round.digits=0, useNA='no'))
```

##### TPCH teams, at risk patients

```{r, results='asis'}
with(baseline, ctable(tpch_team, at_risk, dnn=c('TPCH team',''), round.digits=0, useNA='no'))
```

### On target to reach sample size?

Here we examine if we are on target to reach the sample size. 
The total target sample size is `r 3*7*50*3`, which is 3 at-risk patients per team per week, with 7 teams per hospital, 50 weeks of data collection, and three hospitals. 
We also restrict the sample to patients with at least one follow-up form, as these are necessary for some of the key outcomes.

```{r}
two.weeks = Sys.Date() - 14 # date two weeks ago
# Estimate at risk numbers per hospital per week
numbers = filter(baseline, 
                 admission_date <= two.weeks, # remove most recent weeks (data collection is ongoing)
                 at_risk == 'At risk',
                 complete_456 == 'Yes') %>% # with at least one follow-up form
  select(hospital, admission_date) %>%
  mutate(week = as.numeric(format(admission_date, '%Y')) + as.numeric(format(admission_date, '%U'))/53) %>%
  group_by(hospital, week) %>%
  summarise(n=n()) %>%
  group_by(hospital) %>%
  arrange(week) %>%
  summarise(median = round(median(n)), q1 = round(quantile(n, 0.25)), q3 = round(quantile(n, 0.75)))
flextable(numbers)
```

The table above gives summary statistics (median and inter-quartile range) on the weekly number of at-risk patients with follow-up data available. 
We discard the two most recent weeks, as data collection is likely ongoing.
The target number is `r 3*7` which is 3 patients per week across 7 teams.
We are above the target in two hospitals and below in RBWH.

# Patients screened 

### Screened date

The purpose of this plot is to show the accumulation of patients with complete baseline screening over time.

```{r, out.width='90%'}
# use earliest form date
for.plot = mutate(baseline, 
                  dummy=1,
                  date_seen = as.Date(format(median_form, '%Y-%m-%d'))) %>% # use earliest form for screening date
  group_by(hospital, date_seen, int_time) %>%
  arrange(hospital, date_seen) %>%
  dplyr::select(hospital, date_seen, int_time, dummy) %>%
  group_by(hospital) %>%
  mutate(cum = cumsum(dummy)) %>%
  ungroup()
cplot = ggplot(data=for.plot, aes(x=date_seen, y=cum, lty=int_time, col=factor(hospital)))+
  geom_step()+
  scale_color_manual('Hospital', values=cbPalette)+
  scale_linetype_manual('Time', values=c(1,2,3))+ # add different sizes?
  xlab('Date screened')+
  ylab("Cumulative numbers")+
  g.theme+
  theme(legend.position = c(0.15, 0.65))
cplot
```

### Overall numbers by study time period

The table shows the numbers in each hospital by study time period.

```{r}
tab = group_by(baseline, hospital, int_time) %>%
  tally() %>%
  rename(`Time` = 'int_time')
ftab = flextable(tab) %>%
  theme_box() %>%
  merge_v(j=1) %>%
  autofit()
ftab
```

### At-risk numbers by study time period

The table shows the numbers in each hospital by study time period and the number (percent) at risk.

```{r}
tab = group_by(baseline, hospital, int_time, at_risk) %>%
  tally() %>%
  group_by(hospital, int_time) %>%
  mutate(percent = prop.table(n)*100,
         cell = paste(n, ' (', round(percent), ')', sep='')) %>%
  select(-n, -percent) %>%
  spread(at_risk, cell) %>%
  rename(`Time` = 'int_time')
ftab = flextable(tab) %>%
  theme_box() %>%
  merge_v(j=1) %>%
  autofit()
ftab
```

### Admission time

```{r, out.width='90%'}
hplot = ggplot(data=baseline, aes(x=admission_time, fill=factor(hospital)))+
  geom_histogram(alpha=0.7, breaks=seq(0,24,1))+
  scale_fill_manual('Hospital', values=cbPalette)+
  xlab('Time of day')+
  ylab("Count")+
  scale_x_continuous(breaks=seq(0,24,6))+
  g.theme+
  theme(legend.position = c(0.15, 0.75))
#  facet_wrap(~at_risk)
hplot
```

The majority of patients were admitted in the afternoon and early evening.

### Times between admission and at-risk screening

We examine the time between the patients' admission date/time to the current ward and the InterACT screening. We use two date/times for screening:

* The earliest date/time from the four screening forms: demographics, clinical criteria, functional status and comorbidities. This is an estimate of when screening started.
* The date/time the screening completion form was completed. This is an estimate of when screening ended.

##### Box plots

```{r, fig.width=8}
# add screening form completion date
for_merge = select(complete, participant_id, start_date_time_dcharg) # just date
to_table = left_join(baseline, for_merge, by='participant_id') %>%
  mutate(
    diff_start = (as.numeric(median_form) - as.numeric(admission_datetime))/(60*60*24), # in days from earliest date
    diff_end = (as.numeric(start_date_time_dcharg) - as.numeric(admission_datetime))/(60*60*24), # in days from latest date
    admission_datetime = as.POSIXct(as.numeric(admission_datetime), tz='Australia/Brisbane', origin='1970-01-01'),
    start_date_time_dcharg = as.POSIXct(as.numeric(start_date_time_dcharg), tz='Australia/Brisbane', origin='1970-01-01')
         ) %>% 
  select(participant_id, hospital, admission_datetime, start_date_time_dcharg, diff_start, diff_end, at_risk) %>%
  group_by(participant_id, at_risk) %>%
  gather(`diff_start`, `diff_end`, key='difference', value='var') %>%
  ungroup() %>%
  mutate(difference = ifelse(str_detect(string=difference, pattern='start'), 'Start', 'End'))
# (checks)
check = filter(to_table, var>60) %>%
  select(-at_risk, -var)
write.csv(check, file='checks/admission_dates.csv', row.names = FALSE, quote=FALSE)
# plot
hplot = ggplot(data=to_table, aes(x=var, fill=at_risk))+
  geom_boxplot(width=0.1)+
  scale_fill_manual(NULL, values=cbPalette)+
  xlab('Difference from ward admissision to screening complete (days)')+
  ylab('')+
  facet_grid(difference~hospital)+
  scale_y_continuous(breaks=NULL)+
  scale_x_log10()+
  theme_bw()+
  theme(panel.grid.minor = element_blank())
hplot
```

The time axis is on a log scale (base 10) because of the strong positive skew in the difference in times.

##### Summary statistics

```{r}
stats = group_by(to_table, at_risk, difference, hospital) %>%
  summarise(n = n(),
            missing = sum(is.na(var)),
            q1 = roundz(quantile(var, prob=0.25, na.rm=TRUE),1),
            median = roundz(median(var, na.rm=TRUE),1),
            q3 = roundz(quantile(var, prob=0.75, na.rm=TRUE),1)) %>%
  rename('At risk' = 'at_risk',
         'Screening time' = 'difference',
         'Hospital' = 'hospital')
ft = flextable(stats)
autofit(ft)
```

The statistics are the number observed, number missing, median and inter-quartile range.

# Demographics

### Patient age

The plot is split by CriSTAL/SPICT positive.

```{r, out.width='100%', fig.width=7}
p <- ggplot(filter(baseline, !is.na(at_risk)), aes(x=factor(hospital), y=age, fill=factor(hospital))) + 
  scale_fill_manual('Hospital', values=cbPalette)+
  geom_violin(alpha=0.5)+
  geom_boxplot(width=0.1)+
  xlab('Hospital')+
  ylab('Age')+
  g.theme+
  facet_wrap(~at_risk)
p
```

### Patient gender

```{r, results='asis'}
freq(baseline$pt_sex, cumul=FALSE, report.nas = FALSE)
```

# SPICT 

The SPICT score has a range from 0 to 6 and uses the following six variables:

* Unplanned hospital admission
* Performance status is poor or deteriorating
* Depends on others for care
* Progressive weight loss; remains under weight; low muscle mass
* Persistent symptoms despite optimal treatment of underlying conditions
* Patient (or family) asks for palliative care

Each of the six variables contributes equally to the score. Unknown or missing values are assumed to be "No".

### Correlation matrix of SPICT variables

```{r spict.corr}
# function to make yes/no into number
z_makenum <- function(observed) {
  result = ifelse(observed=='Yes', 1, 0)
  return(result)
}
# estimate correlation matrix
to.corr = select(baseline, spict.vars) %>% # these are just yes/no/unknown
  mutate_all(funs(z = z_makenum(.))) %>%
  select(ends_with('_z')) %>%
  rename_at(vars(ends_with("_z")),funs(str_replace(.,"_z","")))  # remove _z from name
corr <- cor(to.corr, use = 'pairwise')
colnames(corr) = row.names(corr) = nice.rename.spict(colnames(corr)) # rename
# plot
diag(corr) = NA # blank diagonals
ggcorrplot(corr) 
# for text around strongest correlation
max.corr = max(corr[lower.tri(corr, diag=FALSE)])
vars = which(corr==max.corr, arr.ind = T)
```

The plot shows the observed correlation between SPICT variables. Correlations for two variables range from -1 if they are perfectly negatively associated, to 0 if there is no association, to +1 if they are perfectly positively associated.

The strongest positive correlation is `r round(max.corr,2)` between "`r row.names(vars)[1]`" and "`r row.names(vars)[2]`". There were no negative correlations.

### Tables of SPICT variables in each hospital

```{r, results='asis'}
## big summary table
# create summary stats for table / plot
spict = select(baseline, "participant_id", 'hospital', spict.vars) %>%
  tidyr::gather(key='SPICT', value='Response', -`participant_id`, -`hospital`) %>%
  mutate(SPICT = nice.rename.spict(SPICT)) # neaten variable
with(spict, 
     stby(list(x = SPICT, Y = Response), 
          INDICES = hospital, FUN = ctable, totals=FALSE, round.digits=0, useNA='no', dnn=c('SPICT Variable','')))
```


### SPICT score by hospital

```{r, fig.width=8, results='asis'}
to.bar = group_by(baseline, hospital, spict_score) %>%
  summarise(count = n()) %>%
  mutate(fill = as.factor(spict_score >= thresholds$spict_threshold))
spict.bar = ggplot(data=to.bar, aes(x=spict_score, y=count, fill=fill))+ # colour bars by positive
  xlab('SPICT score')+
  ylab('Count')+
  scale_x_continuous(breaks=0:6)+
  geom_bar(stat='identity')+
  scale_fill_manual(NULL, values=c('skyblue','dark blue'))+
  g.theme+
  theme(legend.position = 'none')+
  facet_wrap(~hospital)
spict.bar
```

The darker blue bars show the SPICT-positive patients.

## SPICT positive by hospital

A patient is SPICT positive if their score is `r thresholds$spict_threshold` or greater.

```{r, results='asis'}
baseline = mutate(baseline, 
                  `SPICT positive` = as.numeric(spict_score >= thresholds$spict_threshold),
                  `SPICT positive` = factor(`SPICT positive`, levels=0:1, labels=c('No','Yes')))
with(baseline, ctable(y = `SPICT positive`, x = hospital, round.digits=0, useNA='no', dnn=c('Hospital','')))
```

## Common combinations for SPICT

Here we show the most common combinations of symptoms for patients.

```{r, fig.width=7}
# get combinations of yes responses
yes_responses <-  dplyr::select(baseline, participant_id, spict.vars)  %>%
  as_tibble() %>%
  tidyr::gather(key='spict', value='response', -participant_id) %>%
  filter(response=='Yes') %>% # just yes
  select(-response) %>%
  mutate(spict = nice.rename.spict(spict)  )
# now make list from group responses
list_resp = group_by(yes_responses, participant_id) %>%
  summarise(spicts = list(spict))
# add zeros
all_ids = unique(baseline$participant_id)
missing.ids = all_ids[all_ids %in% list_resp$participant_id == FALSE]
zeros = as_tibble(data.frame(participant_id=missing.ids))
list_resp = bind_rows(list_resp, zeros)
# plot
cplot = ggplot(list_resp, aes(x = spicts)) +
    geom_bar(aes(y=..count../sum(..count..)), fill = "indianred3") +
    g.theme+
    xlab("SPICT combinations") +
    ylab("Proportion of patients") +
    scale_x_upset(n_intersections = 20) # top twenty
cplot
# export to figure
filename = paste('figures/spict_upset', file_plus, '.jpg', sep='')
jpeg(filename, width=5.5, height=4, quality = 100, res=500, units='in')
print(cplot)
invisible(dev.off())
```

# CriSTAL 

The CriSTAL score has a range in this study from 1 to 18. It uses the following 16 variables:

* Age over 75 (_all patients in the InterACT study_)
* Admitted via Emergency Department
* Admitted From nursing home or supported accommodation
* Previous hospitalisation in last 12 months
* ICU admission
* Clinical frailty score (two thresholds at 5+ and 7+)
* Advanced cancer
* Proteinuria
* Chronic kidney disease
* Abnormal ECG
* Acute myocardial infarction
* Chronic heart failure
* COPD
* Stroke
* Cognitive impairment
* Liver disease

And 8 clinical criteria:

* Decreased level of consciousness (LOC) Glasgow Coma Scale (GCS) decreased more than 2 compared with baseline for this person
* Systolic Blood Pressure less than 90 mmHg
* Respiratory Rate less than 5 or greater than 30 bpm	
* Pulse Rate less than 40 or greater than 140 bpm	
* Oxygen required or oxygen saturation less than 90%	
* Hypoglycaemia (BGL 1.0 to 4.0 mmol/L)
* Repeat or prolonged seizures (any type) More than one in 24hrs (including prior to hospital admission) or duration greater than 5 min	
* Low urine output (less than 15 ml/hr or less than 0.5 ml/kg/hr)	

We use two thresholds for the clinical frailty score at 5 or more and 7 or more.

### Correlation matrix of CriSTAL variables

```{r cristal.corr, fig.width=7, fig.height=7}
# function to make yes/no into number
z_makenum <- function(observed) {
  result = ifelse(observed=='Yes', 1, 0)
  return(result)
}
# estimate correlation matrix
to.corr = select(baseline, cristal.vars) %>%
  mutate_at(vars(!ends_with("_cfs_score")), funs(z = z_makenum(.))) %>% # only mutate binary variables
  select(ends_with('_z'), 'cristal_cfs_score') %>%
  rename_at(vars(ends_with("_z")), funs(str_replace(.,"_z",""))) # remove _z from name
corr <- cor(to.corr, use = 'pairwise')
colnames(corr) = row.names(corr) = nice.rename.cristal(colnames(corr)) # rename
colnames(corr)[colnames(corr) == "Frailty score >= 6"] = 'Frailty score'
row.names(corr)[row.names(corr) == "Frailty score >= 6"] = 'Frailty score'
# plot
diag(corr) = NA # blank diagonals
ggcorrplot(corr, tl.cex=8) # cex to reduce text size
# for text around strongest correlations
max.corr = max(corr[lower.tri(corr, diag=FALSE)])
vars.pos = which(corr==max.corr, arr.ind = T)
min.corr = min(corr[lower.tri(corr, diag=FALSE)])
vars.neg = which(corr==min.corr, arr.ind = T)
```

The plot shows the observed correlation between CRiSTAL variables. The strongest positive correlation is `r round(max.corr,2)` between "`r row.names(vars.pos)[1]`" and "`r row.names(vars.pos)[2]`". The strongest negative correlation is `r round(min.corr,2)` between "`r row.names(vars.neg)[1]`" and "`r row.names(vars.neg)[2]`". 

The clinical frailty score is continuous, whereas the other variables are binary. To make the binary variables numeric, we group 'no' and 'unknown' together as zero, and compare them with 'yes' as one.

We did not include age in the correlation plot as every patient is over 75.

### Tables of CriSTAL variables in each hospital

```{r, results='asis'}
## big summary table
# create summary stats for table / plot
cristal = select(baseline, "participant_id", 'hospital', cristal.vars) %>%
  mutate(
    #age = ifelse(age>=75, 'Yes', 'No'), # convert to binary , no longer using age in cristal
         cristal_cfs_score1 = ifelse(cristal_cfs_score >= thresholds$frailty_threshold, 'Yes', 'No'), # frailty score over 5,
         cristal_cfs_score2 = ifelse(cristal_cfs_score >= thresholds$frailty_threshold2, 'Yes', 'No') # frailty score over 7,
         ) %>% 
  select(-cristal_cfs_score) %>% # no longer need score
  mutate_if(is.factor, as.character) %>% # convert all yes/no factors to characters
  tidyr::gather(key='CRISTAL', value='Response', -`participant_id`, -`hospital`) %>%
  mutate(CRISTAL = nice.rename.cristal(CRISTAL)) # neaten variable
# 
with(cristal, 
     stby(list(x = CRISTAL, y = Response), 
          INDICES = hospital, FUN = ctable,  totals=FALSE, round.digits=0, useNA='no', dnn=c('CriSTAL Variable',''))) # no totals, get a bit confusing because of multiple variables
```

### CriSTAL score by hospital

```{r, fig.width=8}
#
MaxC = max(baseline$cristal_score) # for x-axis limit
#
to.bar = group_by(baseline, hospital, cristal_score) %>%
  summarise(count = n()) %>%
  mutate(fill = as.factor(cristal_score >= thresholds$cristal_threshold))
cristal.bar = ggplot(data=to.bar, aes(x=cristal_score, y=count, fill=fill))+ # colour bars by positive
  xlab('CriSTAL score')+
  ylab('Count')+
  scale_x_continuous(breaks=0:MaxC)+
#  scale_y_continuous()
  geom_bar(stat='identity')+
  scale_fill_manual(NULL, values=c('skyblue','dark blue'))+
  g.theme+
  theme(legend.position = 'none')+
  facet_wrap(~hospital)
cristal.bar
```

The darker blue bars show the CriSTAL-positive patients with a score of `r thresholds$cristal_threshold` or greater. 


### CriSTAL score summary statistics by hospital

```{r, cristal.summary, results='asis'}
# would like to fix digits to that N, min, etc are integers, can't use a vector of digits
stby(data = baseline$cristal_score, 
           INDICES = baseline$hospital, 
           FUN = descr, stats = c('N.valid','mean','sd','min','med','max'), transpose = TRUE, round.digits =1)
# TO DO: change N.valid, mean to more user friendly names
# may need to switch to dplyr
```

### CriSTAL positive by hospital

```{r, results='asis'}
baseline = mutate(baseline, 
                  `CriSTAL positive` = as.numeric(cristal_score >= thresholds$cristal_threshold),
                  `CriSTAL positive` = factor(`CriSTAL positive`, levels=0:1, labels=c('No','Yes')))
with(baseline, ctable(y = `CriSTAL positive`, x = hospital, round.digits=0, useNA='no', dnn =c('Hospital','')))
```

A CriSTAL positive score is `r thresholds$cristal_threshold` or above, and we apply this for the entire cohort.

## Common combinations for CriSTAL 

Here we show the twenty most common combinations of sign and symptoms for screened patients. 
We do not show age over 75 in this plot, because everyone in our sample is over this age.
If a CriSTAL variable is not shown, it means it was not used in any of the top twenty combinations.

```{r, fig.width=8}
# get combinations of yes responses
yes_responses <-  dplyr::select(baseline, participant_id, cristal.vars)  %>%
  mutate(
    #age = ifelse(age>=75, 'Yes', 'No'), # convert to binary - no longer using age in cristal
         cristal_cfs_score1 = ifelse(cristal_cfs_score >= thresholds$frailty_threshold, 'Yes', 'No'), # frailty score over 5
         cristal_cfs_score2 = ifelse(cristal_cfs_score >= thresholds$frailty_threshold2, 'Yes', 'No')) %>%  # frailty score over 7
  select(-cristal_cfs_score) %>% # no longer needed
  mutate_if(is.factor, as.character) %>% # convert all yes/no factors to characters
  as_tibble() %>%
  tidyr::gather(key='cristal', value='response', -participant_id) %>%
  filter(response=='Yes') %>% # just yes
  select(-response) %>%
  mutate(cristal = nice.rename.cristal(cristal)  )
# now make list from group responses
list_resp = group_by(yes_responses, participant_id) %>%
  summarise(cristals = list(cristal))
# add zeros
all_ids = unique(baseline$participant_id)
missing.ids = all_ids[all_ids %in% list_resp$participant_id == FALSE]
zeros = as_tibble(data.frame(participant_id=missing.ids))
list_resp = bind_rows(list_resp, zeros)
# plot
# to do, colour bar by threshold?
cplot = ggplot(list_resp, aes(x = cristals)) +
    geom_bar(aes(y=..count../sum(..count..)), fill = "#6855CD") +
    g.theme+
    xlab("CriSTAL combinations") +
    ylab("Proportion of patients") +
    scale_x_upset(n_intersections = 20) # top twenty
cplot
# export to figure
filename = paste('figures/cristal_upset', file_plus, '.jpg', sep='')
jpeg(filename, width=5.5, height=4, quality = 100, res=500, units='in')
print(cplot)
invisible(dev.off())
```

# Clinical frailty score 

Distribution of clinical frailty score by hospital.

```{r, out.width='70%'}
p <- ggplot(baseline, aes(x=factor(hospital), y=cristal_cfs_score, fill=factor(hospital))) + 
  scale_fill_manual('Hospital', values=cbPalette)+
  geom_violin(alpha=0.5, bw=0.8)+ # increase band width to avoid bumps
  geom_boxplot(width=0.1)+
  xlab('Hospital')+
  ylab('Clinical frailty score')+
  scale_y_continuous(breaks=1:9)+
  g.theme
p
```



### Summary of unknowns

Here we look at the number of unknowns as this is useful for identifying variables that are difficult for the auditors to complete. The table below shows the variables with the most amount of unknowns.

```{r}
to_table = select(baseline, participant_id, spict.vars, cristal.vars) %>%
  tidyr::gather(key='variable', value='answer', -participant_id) %>% # to long
  mutate(answer = ifelse(variable =='cristal_cfs_score' & answer=='1', 'Unknown', answer)) %>% # recode unknown for CFS
  filter(answer=='Unknown') %>%
  group_by(variable) %>%
  summarise(Count = n()) %>%
  arrange(-Count) %>%
  mutate(v1 = nice.rename.cristal(variable),
         v2 = nice.rename.spict(variable),
         Variable = ifelse(is.na(v1), v2, v1)) %>%
  select(Variable, Count) %>%
  slice(1:10)
ft = flextable(to_table)
autofit(ft)
```

# Documented care directive prior to this hospital admission

### Numbers with a documented care directive prior to this hospital admission 

For example: Advance Care Plan, Statement of Choices

```{r, results='asis'}
with(baseline, freq(presence_eol_plan, cumul=FALSE, report.nas = FALSE))
```


# Outcome: Clinician-led review discussion

The results in this section only use the first clinician-led review per patient, or for patients without a review the most recently completed form.

### Has a clinician-led care review discussion occurred?

```{r, results='asis'}
# `change_var` is previously `care_review`; renamed because of function
with(clinicianled_review, freq(change_var, round.digits=0, cumul = FALSE, report.nas =FALSE))
```


### Days and times when clinical-led reviews took place

```{r, fig.width=8}
to_plot = circular_plots(clinicianled_review)
grid.arrange(to_plot$week, to_plot$hour, ncol=2)
```

There are `r to_plot$missing_hour` results that are missing the date/time the referral took place.

### Type of clinician-led review activity

```{r, results='asis'}
# only one box can be ticked
with(clinicianled_review, freq(care_review_type, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

### Difference between ward admission date/time and clinician-led review date/time

#### Table of difference (days)

```{r, results='asis'}
# note, convert time to negative
with(clinicianled_review, descr(time_change, stats=c('N.Valid','min','Q1','med','Q3','max'), round.digits=0, cumul = FALSE, report.nas =FALSE))
```

#### Histogram of difference

```{r}
hplot = ggplot(data=clinicianled_review, aes(x=time_change))+
  geom_histogram(fill = "#CDAD00")+
  xlab('Days between ward admission and clinician-led review')+
  g.theme
hplot
```

### Was there any documentation of family conflict?

```{r, results='asis'}
with(clinicianled_review, freq(care_review_conflict, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

# COVID tests

Has the patient tested positive for COVID-19?	

```{r, results='asis'}
with(complete, freq(covid19, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

# Outcomes

From here on the report focuses on outcomes.

```{r scramble, include=FALSE}
# scramble from now on
if(scramble==TRUE){
  min_date = as.numeric(as.POSIXct('2020-05-25 00:00', tz='Australia/Brisbane')) # start of usual care
  max_date = as.numeric(as.POSIXct('2021-06-06 00:00', tz='Australia/Brisbane')) # end of intervention
  set.seed(123456)
  baseline = select(baseline, -'int_time') %>% # remove old time
    mutate(
      median_form = runif(min=min_date, max=max_date, n=nrow(baseline)), # random from earliest start till 400 days plus
    median_form = as.POSIXct(median_form, origin='1970-01-01'))
  baseline = int_time(baseline) # make intervention time, see 99_functions
  # now add to outcomes 
  int_time_data = select(baseline, participant_id, int_time) # data with just intervention time
  clinicianled_review = select(clinicianled_review, -'int_time') %>% # remove old time
    left_join(int_time_data, by='participant_id')
  care_directive = select(care_directive, -'int_time') %>% # remove old time
    left_join(int_time_data, by='participant_id')
  palliative_care_referral = select(palliative_care_referral, -'int_time') %>% # remove old time
    left_join(int_time_data, by='participant_id')
  
  #
  cat('From this point the data are scrambled.\n')
}
```


## Outcome: Care directive review

The results in this section only use the first care directive per patient, or for patients without a review the most recently completed form.

### Has there been a review of any care directives?

```{r, results='asis'}
# `change_var` is previously `change_5`; renamed because of function
with(care_directive, freq(change_var, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

### What care review outcomes occurred?

There were eight outcomes and multiple outcomes could be ticked.

##### Upset plot of outcome combinations

The plot below shows the top ten combinations.

```{r, fig.width=7}
# get combinations of yes responses
yes_responses <- filter(care_directive, change_var=='Yes') %>% # only where there's some care directive
  dplyr::select(participant_id, starts_with('type_care_directive'))  %>%
  as_tibble() %>%
  tidyr::gather(key='outcome', value='response', -participant_id) %>%
  filter(response=='Checked') %>% # just yes
  select(-response) %>%
  mutate(outcome = nice.rename.directive(outcome)  )
# now make list from group responses
list_resp = group_by(yes_responses, participant_id) %>%
  summarise(outcomes = list(outcome))
# add zeros
all_ids = filter(care_directive, change_var=='Yes')$participant_id
missing.ids = all_ids[all_ids %in% list_resp$participant_id == FALSE]
zeros = as_tibble(data.frame(participant_id=missing.ids))
list_resp = bind_rows(list_resp, zeros)
# plot
cplot = ggplot(list_resp, aes(x = outcomes)) +
    geom_bar(aes(y=..count..), fill = "pink") +
    g.theme+
    xlab("") +
    ylab("Number of patients") +
    scale_x_upset(n_intersections = 10) # top ten
cplot
```

##### Frequency table of outcomes

```{r, results='asis'}
to.table = filter(care_directive, change_var =='Yes') %>%
  select(participant_id, starts_with('type_care_')) %>%
  tidyr::gather(key='num', value='checked', -participant_id) %>%
  mutate(nicevar = nice.rename.directive(num),
         num = as.numeric(str_remove_all(num, '[^0-9]')),
         numf = factor(num, levels=1:8, labels=care_directives), 
         checked = factor(checked, levels=c('Checked','Unchecked'), labels=c('Yes','No'))) %>%
  group_by(nicevar, checked) %>%
  tally() %>%
  group_by(nicevar) %>%
  mutate(percent = round(100*prop.table(n)),
         cell = paste(n, ' (', percent, ')', sep=''))
for.table = select(to.table, -n, -percent) %>%
  tidyr::spread(key=checked, value=cell)
#%>%  arrange()
ftab = flextable(for.table) %>%
  autofit()
ftab
#with(to.table, ctable(nicevar, checked, dnn=c(' ',''), order='freq', round.digits=0, totals=FALSE, useNA='no'))
```

##### Bar plot

```{r, fig.width=8}
stack = ggplot(data=to.table, aes(x=nicevar, y=n, fill=checked))+
  geom_bar(position='stack', stat='identity')+
  g.theme+
  scale_x_discrete(limits = rev(unique(to.table$nicevar)))+ # reverse order to match above table
  scale_fill_manual(NULL, values=c("#00BFFF", "#4EEE94", "#FFFFFF"))+
  coord_flip()+
  xlab('')+
  ylab('Count')
stack
```

### Survival analysis of time from ward admission to first care directive review

Here we use survival analysis to examine the time to the first care directive review. We exclude the establishment phase and so compare the usual care and intervention periods. The plot below shows the cumulative incidence for the first care directive review by intervention period.

###### Cumulative risks plots (first 30 days)

```{r}
## set up data, multiple exclusions (these are already defined as high-risk patients)

# to do: competing risk for in-hospital death, waiting on routinely collected data as death is not in REDCAp

# exclude prior:
for_model1 = filter(care_directive, 
                   change_var !='Prior')
n_excluded_prior = nrow(care_directive) - nrow(for_model1)
# exclude establishment phase:
for_model2 = filter(for_model1, 
                   int_time != 'Establishment')
n_excluded_establishment = nrow(for_model1) - nrow(for_model2)
# exclude negative times:
for_model3 = filter(for_model2, 
                   time_change >=0) %>%
    mutate(int_time_n = as.numeric(int_time), # needs to be a number for survminer
           change_var = as.character(change_var), # needed for ifelse below
           change_var = ifelse(change_var=='No', 'Censored', change_var)) # change "No" to "censored" for this analysis. Competing risks are death/event
n_excluded_negative = nrow(for_model2) - nrow(for_model3) 
# cumulative incidence plot
cum_inc = with(for_model3, cuminc(ftime=time_change, fstatus=change_var, group=int_time_n, strata=hospital, cencode='Censored'))
g = ggcompetingrisks(cum_inc,
                 xlab = 'Days',
                 ylab = 'Cumulative probability',
                 xlim = c(0,30), # truncate to interesting days
                 multiple_panels = FALSE,
                 title = '',
#                 gsep = '_', # dummy to prevent groups being created from spaces
                 cumcensor = TRUE, # does not work
                 legend.title='',
                 risk.table = TRUE, # does not work
                 conf_int = TRUE) # does not work
# redo plot for greater control
to_plot = filter(g$data, time<=30) # truncate to interesting days
alt_plot = ggplot(to_plot, aes(x=time, y=est, col=group))+
  geom_line(size = 1.05)+  # make lines thicker
  theme_bw()+
  scale_color_manual(NULL, values=cbPalette, labels=c('Usual care','Intervention'))+
  xlab('Days from ward admission')+
  ylab('Cumulative probability')+
  theme(legend.position = c(0.85, 0.15))
alt_plot
```

There were `r n_excluded_prior` patients excluded because they already had a valid review prior to this admission. `r n_excluded_establishment` patients were excluded as they were in the establishment period. `r n_excluded_negative` were excluded because their times were negative. The number of patients censored was `r sum(for_model3$change_var=='Censored')`.

###### Survival model

```{r}
# Cox model stratified on team
## to do, add competing model for in-hospital death if enough numbers

# add variables from baseline data
data_to_add = select(baseline, participant_id, pt_sex, age, team)
for_model3 = left_join(for_model3, data_to_add, by='participant_id') %>%
  mutate(int_time = relevel(int_time, ref= "Usual care")) # better reference category
# model - do not use Cox, protocol says otherwise
# stratify on hospital
cox_model = coxph(Surv(time = time_change, event = change_var=='Yes') ~ int_time + I(age/5) + pt_sex + strata(team), data = for_model3)
ests = tidy(cox_model, conf.int = TRUE) %>%
  filter(!is.na(estimate)) %>%
  mutate(
    term = nice_rename(term), # see 99_functions
    HR = roundz(exp(estimate),2),
    conf.low = roundz(exp(conf.low),2),
    conf.high = roundz(exp(conf.high),2),
    CI = paste(conf.low, ' to ' , conf.high)) %>%
  select(term, HR, CI)
ft = flextable(ests)
autofit(ft)
```

We used a Cox proportional hazards model stratified on team. The variables included were age, sex and intervention phase which used a reference category of "usual care".

The table shows the hazard ratios (HRs) and 95% confidence intervals (CIs).
Age increased the hazard of the first care directive, meaning it was associated with shorter times to the first clinician-led review. 

##### Survival model checking

###### a) Baseline hazard

Here we plot the baseline hazard in each team. This is useful for checking the differences between hospitals. 

```{r, fig.width=8}
base = basehaz(cox_model, centered=TRUE) %>%
  tidyr::separate(strata, into=c('hospital','team'))
bplot = ggplot(data=base, aes(x=time, y=hazard, col=team))+
  geom_line()+
  scale_x_continuous(limits=c(0,30))+
  xlab('Time, days')+
  facet_wrap(~hospital)+
  g.theme
bplot
```

###### b) Proportional hazards assumption

Here we check the oroportional hazards assumption for Cox models. A non-proportional hazard would mean that a variable would change over time, e.g., age having a greater effect at longer times.

```{r}
p_haz = cox.zph(cox_model)
for_table = as.data.frame(p_haz$table) %>%
  mutate(Variable = row.names(.),
         chisq = round(chisq*100, 0)/100,
         p = format.pval(p, eps=0.001, digits=3)) %>%
  select(Variable, everything())
ftab = flextable(for_table) %>%
  autofit()
ftab
```

###### c) Checking for influential patients

Here we check whether there are influential patients in the Cox survival analysis. An influential patient is one who has a large effect of the estimates and hence any inference.

The plot below shows the 'dfbetas' which are the estimated changes in the regression coefficients after deleting each observation patient in turn. 

```{r}
influence_cox = ggcoxdiagnostics(fit=cox_model, sline=FALSE, type = 'dfbeta', linear.predictions = FALSE, ggtheme = theme_bw())
influence_cox
```

The two patients with unknown sex are relatively influential.


### Days and times when reviews took place

```{r, fig.width=8}
to_plot = circular_plots(care_directive)
grid.arrange(to_plot$week, to_plot$hour, ncol=2)
```

There are `r to_plot$missing_hour` result that are missing the time the review took place.

### Difference in days between ward admission date/time and initiation of care directive review date/time

#### Table of difference

```{r, results='asis'}
# note, convert time to negative
with(care_directive, descr(time_change, stats=c('N.Valid','min','Q1','med','Q3','max'), round.digits=0, cumul = FALSE, report.nas =FALSE))
```

#### Histogram of difference

```{r}
hplot = ggplot(data=care_directive, aes(x=time_change))+
  geom_histogram(fill = "turquoise4")+
  xlab('Days between ward admission and initiation of care directive review')+
  g.theme
hplot
```


### Have the completed document/s been uploaded to 'tracker'?

```{r, results='asis'}
to.table = filter(care_directive, change_var =='Yes')
with(to.table, freq(tracker, round.digits=0, cumul = FALSE, report.nas =FALSE))
```


## Outcome: Palliative care referral

The results in this section only use the first palliative care referral per patient, or for patients without a review the most recently completed form.

### Has this patient been referred to palliative care?

```{r, results='asis'}
# change_var is pall_care
with(palliative_care_referral, freq(change_var, round.digits=0, cumul = FALSE, report.nas =FALSE))
```

### Days and times when referral took place

```{r, fig.width=8}
to_plot = circular_plots(palliative_care_referral)
grid.arrange(to_plot$week, to_plot$hour, ncol=2)
```

There are `r to_plot$missing_hour` result that are missing the time the referral took place.

### Difference in days between ward admission date/time and initiation of palliative care referral date/time

#### Table of difference

```{r, results='asis'}
# note, convert time to negative
with(palliative_care_referral, descr(time_change, stats=c('N.Valid','min','Q1','med','Q3','max'), round.digits=0, cumul = FALSE, report.nas =FALSE))
```

#### Histograms of differences by hospital

```{r, fig.width=8, fig.height=5}
# TO DO: add treatment as a colour when it becomes available
hplot = ggplot(data=palliative_care_referral, aes(x=time_change))+
  geom_histogram(fill = "darkorange1")+
  xlab('Days between ward admission and initiation of care directive review')+
  g.theme+
  facet_wrap(~hospital, scales = 'free')
hplot
```


# Appendices

### Appendix A: Times to complete REDCap study forms (in minutes)

```{r, results='asis'}
# arrange time data for group summary
# to do, add N
long = bind_rows(baseline, care_directive, palliative_care_referral, clinicianled_review, complete) %>% # combine all forms with start/end times
  select(participant_id, starts_with('time')) %>%
  tidyr::gather(key='form', value='minutes', -`participant_id`) %>%
  select(-`participant_id`) %>% # avoid this being summarised
  mutate(form = case_when(form=='time_dem' ~ 'Patient demographics',
                          form=='time_hosp' ~ 'Hospital admissions',
                          form=='time_funct' ~ 'Functional status',
                          form=='time_comorb' ~ 'Comorbidities',
                          form=='time_4' ~ 'Clinician-led review discussion',
                          form=='time_5' ~ 'Care directive measure',
                          form=='time_6' ~ 'Palliative care referral',
                          form=='time_dcharg' ~ 'Screening completion'))
#
stby(data = long, 
           INDICES = long$form, 
           FUN = descr, stats = "fivenum", transpose = TRUE)
```

The results above show there are some data entry errors in the date/times for hospital admissions.

<!--- ##c("#FFFFFF", "#FFFFFF", "#FFFFFF") Appendix B: R version info , add at later date --->
<!--- The list below shows the version of the R software and all the packages. This is only needed for technical queries. It also helps with computational reproducibility.--->


